<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>000. Hello World - 用Github pages和Hexo搭建自己的个人主页</title>
    <url>/2022/02/24/000-hello-world/</url>
    <content><![CDATA[<p><strong>Hello world</strong><br>欢迎来到我的博客，我是Kennan，一名计算机专业的研究生。以前在不同的地方写一些文章博客，但会受到平台的各种限制和广告。<br>这里在前辈的指导下，通过 <a href="https://docs.github.com/en/pages">github pages平台</a> 和 <a href="https://hexo.io/">Hexo博客框架</a> 搭建了一个自己的个人主页，在上面分享一些自己的经历和学习心得。<br>下面记录一下我的搭建过程，请多多指教，一些相关文件可参考我的 <a href="https://github.com/KennanYang/KennanYang.github.io">KennanYang.github.io</a> 项目</p>
<span id="more"></span>
<h2 id="1-搭建Hexo"><a href="#1-搭建Hexo" class="headerlink" title="1.搭建Hexo"></a>1.搭建Hexo</h2><p><a href="https://hexo.io/">Hexo</a>是基于Node.js写的，也需要git管理文章上传到github，所以需要先安装git和nodeJS</p>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>windows：到git官网上下载,<a href="https://gitforwindows.org/">Download git</a><br>linux: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p>使用<code>git --version</code>查看是否安装正确</p>
<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>windows：<a href="https://nodejs.org/en/">Node.js官网</a>选择LTS版本（稳定版）。</p>
<p>linux：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure>
<p>使用<code>node -v</code>和<code>npm -v</code>查看是否安装正确</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>创建一个文件夹【filename】(我的叫 hexoblog)，然后<code>cd</code>到这个文件夹下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>用<code>hexo -v</code>查看一下版本</p>
<p>至此，安装完毕，开始配置Hexo项目</p>
<h3 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h3><p>初始化Hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init hexoblog</span><br><span class="line"><span class="built_in">cd</span> hexoblog //进入这个hexoblog文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>然后就可以查看官方的demo了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate //产生网页，可缩写hexo g</span><br><span class="line">hexo server //挂到本地服务器打开，可缩写hexo s</span><br></pre></td></tr></table></figure>

<p>在浏览器输入localhost:4000就可以看到你生成的博客，官方默认主题是landscope</p>
<h2 id="2-部署到github-pages"><a href="#2-部署到github-pages" class="headerlink" title="2.部署到github pages"></a>2.部署到github pages</h2><p>直接在github page平台上托管我们的博客，便于维护，下面是把Hexo搭好的博客部署到github pages的配置方式。</p>
<h3 id="注册github，新建repo"><a href="#注册github，新建repo" class="headerlink" title="注册github，新建repo"></a>注册github，新建repo</h3><p>新建一个自己用户名命名的仓库，后面加.github.io，像我这样，其他设置默认就好，点击create repository。<br><img src="https://img-blog.csdnimg.cn/c5bdfacd70c94789bcbe12c7a1c01da9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6LSwS2VubmFu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="创建repo"></p>
<h3 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h3><p>回到你的git bash中，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后创建SSH,一路回车</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。<br><img src="https://img-blog.csdnimg.cn/1b4a2ce586c5423c91354dd38ecee893.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6LSwS2VubmFu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="ssh密钥"><br>ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。<br><img src="https://img-blog.csdnimg.cn/51f61bbe5dc64632be0158105eb15d3b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6LSwS2VubmFu,size_11,color_FFFFFF,t_70,g_se,x_5" alt="github-&gt;settings"></p>
<p>而后在GitHub的setting中，找到SSH keys的设置选项，点击<code>New SSH key</code>把你的<code>id_rsa.pub</code>里面的信息复制进去。<br><img src="https://img-blog.csdnimg.cn/b3cb64a9604946a38fc3f8bd85ce4f6a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6LSwS2VubmFu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>在gitbash中，查看是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<h3 id="部署Hexo到github"><a href="#部署Hexo到github" class="headerlink" title="部署Hexo到github"></a>部署Hexo到github</h3><p>打开站点配置文件 _config.yml，翻到最后，修改为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/YourgithubName/YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。<br><code>hexo generate</code> 是生成静态文章，可以用 <code>hexo g</code>缩写<br><code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写</p>
<p>注意deploy时可能要你输入username和password。</p>
<p>部署后需要<strong>等待一段时间</strong>，然后就可以在<code>http://yourname.github.io</code>看到Hexo 博客了，这里的内容和<code>hexo server</code>生成的内容完全相同。</p>
<h2 id="3-绑定个人域名"><a href="#3-绑定个人域名" class="headerlink" title="3.绑定个人域名"></a>3.绑定个人域名</h2><p>完成上面的步骤后，可以使用<code>http://yourname.github.io</code>查看个人主页，如何自定义一个属于自己的域名呢？</p>
<h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>注册一个<a href="https://www.aliyun.com/?spm=5176.100251.top-nav.dlogo.5af94f152mfbDz">阿里云账户</a>,在阿里云上买一个域名，我买的是<code>kennan-yang.top</code></p>
<p>先实名认证，然后在域名控制台添加解析，这里需要<strong>等半天时间</strong>。<br><img src="https://img-blog.csdnimg.cn/05356c75bdfa48d593e1789995afe188.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6LSwS2VubmFu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="域名解析"><br>登录GitHub，进入之前创建的仓库<code>yourname.github.io</code>，点击<code>settings-&gt;pages</code>，设置<code>Custom domain</code>，输入你的域名<code>kennan-yang.top</code> 并<code>save</code>。<br><img src="https://img-blog.csdnimg.cn/4ca6ad5c655b4eaab7f534ed8cc78ab7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN6LSwS2VubmFu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="Custom domain"></p>
<h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>然后在你的博客文件夹（如我的hexoblog）的<code>source</code>目录中创建一个名为<code>CNAME</code>文件，不要后缀。写上你的域名。<br><img src="https://img-blog.csdnimg.cn/e26efd4edb2a4772a54ded2542a28b14.png" alt="CNAME"><br>然后就是最常用的下面几条命令，当配置完成之后进行这些操作即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean <span class="comment"># 清理缓存</span></span><br><span class="line">hexo g <span class="comment"># hexo generate 生成静态页</span></span><br><span class="line">hexo s <span class="comment"># hexo server 本地预览（非必须）</span></span><br><span class="line">hexo d <span class="comment"># hexo deploy 部署到github pages</span></span><br></pre></td></tr></table></figure>
<p>部署完成后就可以用你的域名打开自己的博客啦！</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Hexo还有更多不同的主题和配置，可参考下面的资料进行个性化设置。</p>
<ol>
<li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">CSDN: hexo史上最全搭建教程</a></li>
<li><a href="https://docs.github.com/en/pages">github pages</a> </li>
<li><a href="https://hexo.io/">Hexo官方文档</a></li>
<li><a href="https://shen-yu.gitee.io/">Hexo的岛主题</a></li>
</ol>
]]></content>
      <categories>
        <category>搭建环境</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>搭建环境</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/06/15/010-hexo-problems/</url>
    <content><![CDATA[<p>在hexo配置个人主页的过程中，遇到一些环境配置问题，在这里整理一下大神们的解决办法：</p>
<p>1.主页打不开的问题：</p>
<p>打开github主页时发现<strong>404</strong>，通过 <strong><em>hexo server</em></strong> 命令打开本地的主页配置时发现 Cannot Get/,所以搜索了一下解决办法，最终参考<a href="https://blog.csdn.net/loveLifeLoveCoding/article/details/121789466">vue项目Error: Cannot find module ‘xxx’类报错的解决方法</a> 解决了主页打不开的问题。</p>
<span id="more"></span>
<p>2.数学公式问题：</p>
<p>这个问题是当我根据marktown写数学公式时，发现vscode上显示公式正确，但是配置到主页上时，公式就变成了源码，通过学习这个博客 <a href="https://blog.csdn.net/weixin_45511189/article/details/115798563">hexo博客next主题添加对数学公式的支持</a>，得到解决。</p>
<p>marktown的数学公式语法规则为：<a href="https://www.jianshu.com/p/f0de9f572c9d">Marktown数学公式</a></p>
]]></content>
      <categories>
        <category>搭建环境</category>
      </categories>
      <tags>
        <tag>搭建环境</tag>
      </tags>
  </entry>
  <entry>
    <title>009. 机器学习：车辆分割任务和卷积神经网络课堂实践</title>
    <url>/2022/06/15/009-FCN-car-recognition/</url>
    <content><![CDATA[<p>这是在学习《机器学习基础》课程的<strong>神经网络</strong>这一章时，做的期末大作业，详见《机器学习（周立华）》第五章，记录一下以便回顾。</p>
<p>数据集: kaggle车辆分割数据集<br>完整代码见github：<a href="https://github.com/KennanYang/Kaggle_car_segmentation">车辆分割任务和卷积神经网络课堂实践</a></p>
<span id="more"></span>
<h2 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h2><p>本实验的模型主要参考<a href="https://blog.csdn.net/qq_36269513/article/details/80420363">FCN语义分割模型</a>，代码部分参考了<a href="https://blog.csdn.net/u014453898/article/details/92080859">手提包分割代码</a>。</p>
<h3 id="1-模型思路"><a href="#1-模型思路" class="headerlink" title="1.模型思路"></a>1.模型思路</h3><p><img src="https://pic.imgdb.cn/item/62a95ff40947543129ab41ae.png" alt="图 1模型结构示意图"><br>如图1所示，模型由两部分组成：上方蓝绿相间的<strong>下采样卷积部分</strong>与下方的<strong>上采样部分</strong>。总体思路是通过卷积过程，将原图一步一步提取出高维全局特征，再使用反卷积操作由高维全局特征还原成原图大小的像素级分类结果。</p>
<p>本项目的下采样卷积部分取用的是 <a href="https://baijiahao.baidu.com/s?id=1667221544796169037&wfr=spider&for=pc">VGG net网络</a> 卷积部分，其优势是网络结构规整，全网络采用的卷积核尺寸以及池化尺寸均一致, 进行反卷积的尺寸计算较为方便; 且有不同类型的网络结构可以进行横向对比; VGG net通过加深网络深度, 对特征提取的效果也有显著的提升。 </p>
<p>本项目的上采样部分采用反卷积的方式，该方式为上采样的经典操作，通过填充再正向卷积两个步骤，将原来较小尺寸的输入扩大到较大尺寸的输出，并保留了输入时的必要信息。在本项目的实际操作中，并没有将卷积层的输出直接一步还原成原图大小的最终输出，而是一步一步地放大并与所有的池化层输出进行结合，最终还原成原图的大小。</p>
<h3 id="2-下采样"><a href="#2-下采样" class="headerlink" title="2.下采样"></a>2.下采样</h3><p>下采样部分包含了传统的卷积层与池化层，卷积层即使用卷积核对输入进行卷积运算，运算过程示意如图2所示，卷积核对当前卷积层输入进行从左到右、自上而下的扫描，每一步输出一个结果，如果扫描的是多通道输入，则对每一个通道进行扫描，每一步将多个通道对应的多个结果进行加和即可。</p>
<p><img src="https://pic.imgdb.cn/item/62a95ff40947543129ab4196.png" alt="图 2卷积运算"></p>
<p>池化层的池化运算如图3所示，即对输入进行类似卷积运算中的扫描过程，以最大池化层为例，每一步对窗口中的最大元素进行输出。</p>
<p><img src="https://pic.imgdb.cn/item/62a95ff40947543129ab418e.png" alt="图 3池化运算"></p>
<h3 id="3-上采样"><a href="#3-上采样" class="headerlink" title="3.上采样"></a>3.上采样</h3><p>本项目采用的反卷积操作进行上采样，Pytorch对反卷积已有了完整可调用的封装函数，而其具体的运算过程分为两步：填充、正向卷积。</p>
<p><img src="https://pic.imgdb.cn/item/62a95ff40947543129ab4187.png" alt="图 4填充过程"></p>
<p>填充过程如图4所示，填充后输入矩阵中的各行各列元素之间会相隔一层0，对于“same”类型的卷积运算，还会在矩阵外圈填充一层0，这样的填充结果即为图3右边所示。<br>需要注意的是，输出尺寸是由输入尺寸、正向卷积核大小、填充数决定，如果程序发现当前填充数得到的输出尺寸不满足预定的输出尺寸（即当前输出尺寸偏小），会继续填充，其补填方式是在左侧与上侧继续填充一层0，直至输出尺寸达到预定要求。上述以填充0为例进行说明，而操作者可根据实际情况自定义填充内容，默认填充值为0。</p>
<p>在填充完成后，第二步将进行正向卷积，其卷积运算与下采样部分的卷积运算相同，都是使用卷积核进行扫描、对应位置相乘并相加、多通道输出再相加。输入尺寸经过填充后会被放大一定程度，正向卷积又会减小一定程度，但最后的尺寸会根据填充数、正向卷积核尺寸、步长等变量进行计算，且大于输入尺寸。</p>
<p>考虑到下采样部分的特征提取具有从细节到抽象、从局部到全局的特点，通俗来说可以描述为，网络在卷积部分开始时学习到的是图像某一部分的特征，而前向传播到网络后半程时，网络所掌握到的是对整个图像的总体印象。</p>
<p>不难发现，如果只使用卷积网络最后的输出进行上采样，则保留的信息是全局信息，缺乏细节信息对于总体精度的调整，因此本项目将卷积网络中所有的池化层输出都融入了上采样过程当中，具体做法是：</p>
<p>（1）将卷积网络输出作为当前的上采样对象，将最后一个池化层作为目标池化层<br>（2）对上采样对象进行反卷积，尺寸扩大一定程度，且通道数也进行扩充，使之与目标池化层尺寸与通道数一致。<br>（3）将（2）中反卷积后的结果与目标池化层进行对应元素相加。<br>（4）将（3）操作结束后的输出作为当前的上采样对象，将当前目标池化层的前一个池化层替换当前的目标池化层。跳回（2），循环至所有池化层被融入整个上采样过程。<br>（5）将最后的结果进行正向卷积，还原成原图片尺寸，此时的输出即为该样本的像素级分类结果。</p>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="1-图像缩放"><a href="#1-图像缩放" class="headerlink" title="1.图像缩放"></a>1.图像缩放</h3><p>为了达到降低数据维度减少训练模型时间的目的，同时保证缩小后的图片仍能保留原图片的关键信息，因此将图片尺寸缩小到（192，128）。缩小方法采用双线性插值法，即在两个方向分别进行一次线性插值，见下图：<br><img src="https://pic.imgdb.cn/item/62a95ff40947543129ab41bc.png" alt="图 5 双线性插值法"><br>假如我们想得到未知函数 f 在点 P &#x3D; (x, y) 的值，假设我们已知函数 f 在 $Q_{11}  &#x3D; (x_1, y_1)、Q_{12} &#x3D; (x_1, y_2), Q_{21} &#x3D; (x_2, y_1) 以及 Q_{22} &#x3D; (x_2, y_2)$ 四个点的值。f就是一个像素点的像素值。首先在 x 方向进行线性插值，得到<br><img src="https://pic.imgdb.cn/item/62a962d90947543129af372e.png"><br>然后在 y 方向进行线性插值，得到<br><img src="https://pic.imgdb.cn/item/62a962d90947543129af36c6.png"><br>综合起来就是双线性插值最后的结果：<br><img src="https://pic.imgdb.cn/item/62a962d90947543129af3658.png"><br>图像双线性插值只会用相邻的4个点,最终还要将源图像和目标图像几何中心的对齐：<br><img src="https://pic.imgdb.cn/item/62a962d90947543129af361d.png"></p>
<h3 id="2-归一化"><a href="#2-归一化" class="headerlink" title="2.归一化"></a>2.归一化</h3><p>把数据变成(0，1)之间的小数，为了数据处理的方便性和正确性，便于不同单位或量级的指标能够进行比较和加权。归一化是一种简化计算的方式，即将有量纲的表达式，经过变换，化为无量纲的表达式，成为纯量。</p>
<p>本次实验数据为图片，处理的数值为像素点，由于像素点的值在（0，255）之间，采用区间放缩法，将数据映射到（0，1）之间。即：</p>
<p>$x’ &#x3D; (x - X_{min}) &#x2F; (X_{max} - X_{min})$</p>
<h3 id="3-标准化"><a href="#3-标准化" class="headerlink" title="3.标准化"></a>3.标准化</h3><p>标准化是依照特征矩阵的列处理数据，其通过求z-score的方法，转换为标准正态分布，和整体样本分布相关，每个样本点都能对标准化产生影响。<br>即：$x’ &#x3D; (x - μ)／σ$，<br>其中μ为均值，σ为标准差。</p>
<h3 id="4-独热编码"><a href="#4-独热编码" class="headerlink" title="4.独热编码"></a>4.独热编码</h3><p>独热编码即 One-Hot 编码，又称一位有效编码，其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候，其中只有一位有效。对于每一个特征，如果它有m个可能值，那么经过独热编码后，就变成了m个二元特征。并且，这些特征互斥，每次只有一个激活。因此，数据会变成稀疏的。</p>
<p>这样做解决了分类器不好处理属性数据的问题，并且在一定程度上也起到了扩充特征的作用。</p>
<h3 id="5-数据集划分"><a href="#5-数据集划分" class="headerlink" title="5.数据集划分"></a>5.数据集划分</h3><p>由于提供的数据集中的测试集并无标签信息，因此将训练集按照3：1：1的比例将其划分为训练集、验证集和测试集。</p>
<p>训练集用以训练模型优化参数，验证集用来实时输出总损失值，用以决定合适的迭代次数，避免欠拟合、过拟合以及局部最优。测试集用以计算评价指标，以反映模型效果的好坏。</p>
<h2 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h2><h3 id="1-预测结果展示"><a href="#1-预测结果展示" class="headerlink" title="1.预测结果展示"></a>1.预测结果展示</h3><p><img src="https://pic.imgdb.cn/item/62a963fb0947543129b0eadc.png" alt="图 6 测试集原图（左）和预测结果（右）对比展示"></p>
<p>这是使用1008个样本的测试集预测之后的结果。其中，左图为原来的车辆图片，分辨率为1918<em>1280。右图为预测之后形成的灰度图，考虑到性能限制，压缩到分辨率为192</em>128。</p>
<p>可以看到预测结果基本符合预期。</p>
<h3 id="2-MIoU语义分割标准度量"><a href="#2-MIoU语义分割标准度量" class="headerlink" title="2.MIoU语义分割标准度量"></a>2.MIoU语义分割标准度量</h3><p><img src="https://pic.imgdb.cn/item/62a963fb0947543129b0eacd.png" alt="图 7 MIoU语义分割标准度量原理示意图"><br>Mean Intersection over Union（MIoU，均交并比）为语义分割的标准度量。其计算两个集合的交集和并集之比，在语义分割问题中，这两个集合为真实值和预测值。</p>
<p>首先计算单张图片预测结果的交并比，然后把所有测试集中的图片预测结果的交并比取平均值，即可获得MIoU评价指标。</p>
<p>在本次实验中，对比了4种VGG网络模型以及不同迭代次数下的MIoU指标，对比结果如折线图所示。</p>
<p><img src="https://pic.imgdb.cn/item/62a963fb0947543129b0eac5.png" alt="图 8 对比四种网络结构和不同迭代次数下的MIoU结果"></p>
<p>由图中可以看出：<br>1.这四个网络前期收敛速度是差不多的，随着迭代次数的增加，准确度趋于平稳。<br>2.性能最好的情况为采用VGG16网络，迭代100次下的网络模型。最优MIoU指数可达到0.9639。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.FCN的学习及理解<br><a href="https://blog.csdn.net/qq_36269513/article/details/80420363">https://blog.csdn.net/qq_36269513/article/details/80420363</a></p>
<p>2.卷积神经网络VGG16详解<br><a href="https://baijiahao.baidu.com/s?id=1667221544796169037&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1667221544796169037&amp;wfr=spider&amp;for=pc</a></p>
<p>3.MIoU 源码解析——TensorFlow 和 PyTorch 源码解析<br><a href="https://zhuanlan.zhihu.com/p/141704816">https://zhuanlan.zhihu.com/p/141704816</a></p>
<p>4.pytorch用FCN语义分割手提包数据集<br><a href="https://blog.csdn.net/u014453898/article/details/92080859">https://blog.csdn.net/u014453898/article/details/92080859</a></p>
<p>5.《机器学习》，周志华著</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>008. 机器学习：聚类任务和k_means算法课堂实践</title>
    <url>/2022/06/15/008-k-means/</url>
    <content><![CDATA[<p>这是在学习《机器学习基础》课程的<strong>聚类</strong>这一章时，做的课堂实践内容，详见《机器学习（周立华）》第九章，记录一下以便回顾。<br>数据集使用 <a href="http://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-10数据集</a><br>完整代码见github：<a href="https://github.com/KennanYang/mechine-learning/blob/master/week11_k_means.ipynb">聚类和k均值算法课程实践</a></p>
<span id="more"></span>
<h2 id="机器学习算法基础"><a href="#机器学习算法基础" class="headerlink" title="机器学习算法基础"></a>机器学习算法基础</h2><h3 id="聚类任务和k-means算法"><a href="#聚类任务和k-means算法" class="headerlink" title="聚类任务和k-means算法"></a>聚类任务和k-means算法</h3><p><strong>聚类（Clustering）</strong> 是一种无监督学习。目的是通过对<strong>未标记训练样本</strong>的学习来解释数据的固有属性和规律，为进一步的数据分析提供基础。<br>通过对数据集进行划分，形成<strong>簇结构（cluster）</strong>。<br>实验采用 <strong>k-means算法</strong> 对数据集进行分割。<br>给定样本集D，<strong>k-means</strong>算法使平方误差最小化<br><img src="https://pic.imgdb.cn/item/62a9499d09475431298ce88d.png" alt="平方误差"><br>对于聚类得到的聚类划分$C={C_1,C_2，…，C_k}$，其中$μ_i=1/(| C_i |)∑_(x∈C_i)$, x是聚类C的均值向量。该公式描述了聚类中样本与聚类均值向量之间的密切程度。</p>
<p>E值越小，表示聚类中样本的相似性越高。</p>
<p>K-means采用贪心策略通过迭代优化来逼近该公式。在迭代更新过程中，每个聚类中的样本与平均向量之间的距离会变短。这个距离可以用不同的范式来计算。</p>
<p>当达到调整范围的阈值时，停止迭代，输出一个近似最优的聚类分类结果。在本实验中，该阈值被设置为0.0001。</p>
<h3 id="DBI评价指标"><a href="#DBI评价指标" class="headerlink" title="DBI评价指标"></a>DBI评价指标</h3><p>对于聚类结果，我们需要通过一些性能指标来评估其质量。</p>
<p>本实验使用内部指标 <strong>Davies-Bouldin（DB）指数</strong> 来衡量聚类的性能。<br><strong>DB指数</strong>的思想是希望C簇中样本之间的平均距离之和尽可能小，不同簇的中心点之间的距离尽可能大。<br>这意味着聚类分类后的样本更加集中。使聚类结果具有较高的“簇<strong>内</strong>相似度”和较低的“簇<strong>间</strong>相似度”。<br>DBI算法如下:<br>Davies-Bouldin指数:<br><img src="https://pic.imgdb.cn/item/62a9540c09475431299ab059.png" alt=""><br>C类样本间的平均距离:<br><img src="https://pic.imgdb.cn/item/62a9543a09475431299b0a55.png" alt=""><br>簇C_i的中心点到簇C_j的距离:<br><img src="https://pic.imgdb.cn/item/62a9543a09475431299b0acc.png" alt=""><br>$dist(·，·)$用于计算两个样本之间的距离，这里的距离计算采用欧氏距离，即p=2;</p>
<p><img src="https://pic.imgdb.cn/item/62a9543b09475431299b0b02.png" alt=""><br>μ表示簇C的中心点:<br><img src="https://pic.imgdb.cn/item/62a954c909475431299c02db.png" alt=""></p>
<h2 id="实验结果展示"><a href="#实验结果展示" class="headerlink" title="实验结果展示"></a>实验结果展示</h2><p>JupyterLab的python程序运行结果如下：<br><img src="https://pic.imgdb.cn/item/62a9550c09475431299c84f6.png" alt=""></p>
<p>首先，展示测试图像。每个标签显示5个图片，10个标签有10列。</p>
<p>然后信息按顺序显示:<br>当k为6到10，范数为L1或L2时，DBI是不同的。<br>展示最小的DBI和最佳的聚类分区。<br>最后给出DBI最小的簇的图像。每个标签显示5张图片，k个标签有k列。</p>
<p>注: 由于初始均值向量是随机选择的，因此DBI结果略有不同。由于最小DBI的聚类结果相同，对聚类结果没有影响。当初始均值向量选择相同时，DBI结果相同。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.CIFAR-10数据集下载: <a href="http://www.cs.toronto.edu/~kriz/cifar.html">http://www.cs.toronto.edu/~kriz/cifar.html</a></p>
<p>2.《机器学习（周立华）》（西瓜书）</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>007. 机器学习：支持向量机（SVM）课堂实践</title>
    <url>/2022/06/15/007-SVM/</url>
    <content><![CDATA[<p>这是在学习《机器学习基础》课程的支持向量机这一章时，做的课堂实践内容，详见《机器学习（周立华）》第六章，记录一下以便回顾。<br>数据集使用 <a href="http://yann.lecun.com/exdb/mnist/">Mnist-image数据集</a><br>完整代码见github：<a href="https://github.com/KennanYang/mechine-learning/blob/master/week7_SVM.ipynb">SVM课程实践</a></p>
<span id="more"></span>

<h2 id="机器学习算法基础"><a href="#机器学习算法基础" class="headerlink" title="机器学习算法基础"></a>机器学习算法基础</h2><h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><p>在这个实验中，<strong>支持向量机（Support Vector Macchine,简称SVM）</strong> 被用来解决分类问题。目的是找出区间最大的划分超平面。SVM的基本类型是<br><img src="https://pic.imgdb.cn/item/62a93fc309475431297f94bc.png"><br>对于高维特征空间，可以通过训练样本的 <strong>核函数（Kernel）</strong> 展开模型的最优解，获得支持向量展开<br><img src="https://pic.imgdb.cn/item/62a93fc309475431297f9466.png"></p>
<h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3><h4 id="1-线性核"><a href="#1-线性核" class="headerlink" title="1.线性核"></a>1.线性核</h4><p>线性核（Linear Kernel）的实现使用sklearn库中SVC函数的默认参数 <em><strong>(‘ linear ‘)</strong></em> 。<br>线性核函数是：<br><img src="https://pic.imgdb.cn/item/62a93fc309475431297f9471.png"></p>
<h4 id="2-径向基核"><a href="#2-径向基核" class="headerlink" title="2.径向基核"></a>2.径向基核</h4><p>径向基核函数(Radial Basis Function,简称RBF，也叫高斯核)的实现也使用了sklearn库中SVC函数的默认参数 <em><strong>(‘ rbf ‘)</strong></em> 。<br>RBF核函数为：<br><img src="https://pic.imgdb.cn/item/62a93fc309475431297f9486.png"></p>
<h4 id="3-自定义核函数"><a href="#3-自定义核函数" class="headerlink" title="3.自定义核函数"></a>3.自定义核函数</h4><p>利用 <strong>核函数的性质</strong> 构造了一个新的核函数: 两个核函数的直积也是一个核函数。<br>К1 是线性核，К2 是拉普拉斯核：<br><img src="https://pic.imgdb.cn/item/62a945890947543129873256.png"></p>
<p>自定义一个核函数： К1 ⊗ К2.<br>К1和К2的内核函数是通过自己编写的python函数实现的，在径向基和线性核的编程过程中展示了更多的细节。<br><img src="https://pic.imgdb.cn/item/62a94252094754312983607a.png"></p>
<h3 id="python工具包"><a href="#python工具包" class="headerlink" title="python工具包"></a>python工具包</h3><p>Python的scikit-learn库有SVC工具包，可以自定义以下参数。<br><em><strong>C: float, default&#x3D;1.0</strong></em><br>-正则化参数<br><em><strong>Kernel {‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’, ‘precomputed’}, default&#x3D;’rbf’</strong></em><br><em><strong>Degree: int, default&#x3D;3</strong></em><br>-Degree是多项式核函数 <em><strong>(‘ poly ‘)</strong></em> 的阶数，其他核基本忽略该参数。<br>有很多参数，但在本次实验中，只修改了核函数，其他参数使用默认值。</p>
<h2 id="实验结果展示"><a href="#实验结果展示" class="headerlink" title="实验结果展示"></a>实验结果展示</h2><p>JupyterLab的python程序运行结果：<br><img src="https://pic.imgdb.cn/item/62a93fc309475431297f9495.png"></p>
<p>从结果来看:<br>首先，展示测试图像。每个标签显示三张图片，按照000-999的矩阵输出，对应的数字如图所示。<br>然后分别用 <strong>线性核函数、径向基核函数、自定义核函数</strong> 三种核函数构造SVM，用训练集进行模型训练，用测试集衡量识别精度，输出识别准确率评价指标按顺序显示。<br>ps.从结果看，自定义核并不适合这个任务。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.Mnist-image数据集下载: <a href="http://yann.lecun.com/exdb/mnist/">http://yann.lecun.com/exdb/mnist/</a></p>
<p>2.scikit-learn库的安装和SVC的API:<br><a href="https://scikit-learn.org/stable/index.html">https://scikit-learn.org/stable/index.html</a></p>
<p>3.《机器学习（周立华）》（西瓜书）</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>006. HTTP协议详解</title>
    <url>/2022/05/30/006-HTTP-HTTPS/</url>
    <content><![CDATA[<p>HTTP协议是网络编程的基础知识，后端开发应当熟练掌握，但是相关内容较多。</p>
<p>之前在学校学的都忘记了，最近为了找工作又复习起来，参考了力扣上的教程和一些网上资料，做一个总结，并补充一些常问的八股方便回顾。</p>
<p><a href="https://leetcode.cn/leetbook/read/tech-interview-cookbook/o9ga26/">校招基础知识详解-HTTP</a></p>
<span id="more"></span>
<h2 id="URL解析过程"><a href="#URL解析过程" class="headerlink" title="URL解析过程"></a>URL解析过程</h2><p>当输入网址时会发生什么呢？提到HTTP就不能不先了解一下URL的解析过程。</p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>在WWW上，每一信息资源都有统一的且在网上唯一的地址，该地址就叫<strong>URL（Uniform Resource Locator,统一资源定位器）</strong>，它是WWW的统一资源定位标志，就是指网络地址。</p>
<h3 id="浏览器输入地址后发生什么？"><a href="#浏览器输入地址后发生什么？" class="headerlink" title="浏览器输入地址后发生什么？"></a>浏览器输入地址后发生什么？</h3><p>1、域名解析： 浏览器获得URL地址，向操作系统请求该URL对应的IP地址，操作系统查询DNS（首先查询本地HOST文件，没有则查询网络）获得对应的IP地址</p>
<p>解释：</p>
<p>把URL分割成几个部分：协议、网络地址、资源路径</p>
<p>协议：指从该计算机获取资源的方式，常见的是HTTP、FTP</p>
<p>网络地址：可以是域名或者是IP地址，也可以包括端口号，如果不注明端口号，默认是80端口</p>
<p>如果地址不是一个IP地址，则需要通过DNS（域名系统）将该地址解析成IP地址，IP地址对应着网络上的一台计算机，DNS服务器本身也有IP，你的网络设置包含DNS服务器的IP，例如，<a href="http://www.abc.com不是一个ip,则需要向dns询问请求www.abc.com对应的ip,获得ip,在这个过程中,你的电脑直接询问dns服务器可能没有发现www.abc.com对应的ip,就会向它的上级服务器询问,这样依次一层层向上级找,最高可达根节点,直到找到或者全部找不到为止/">www.abc.com不是一个IP，则需要向DNS询问请求www.abc.com对应的IP，获得IP，在这个过程中，你的电脑直接询问DNS服务器可能没有发现www.abc.com对应的IP，就会向它的上级服务器询问，这样依次一层层向上级找，最高可达根节点，直到找到或者全部找不到为止</a></p>
<p>端口号就相当于银行的窗口，不同的窗口负责不同的服务，如果输入<a href="http://www.abc.com:8080/%EF%BC%8C%E5%88%99%E8%A1%A8%E7%A4%BA%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%8480%E7%AB%AF%E5%8F%A3%EF%BC%8C%E8%80%8C%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AE%9A%E7%9A%848080%E7%AB%AF%E5%8F%A3">www.abc.com:8080/，则表示不使用默认的80端口，而使用指定的8080端口</a></p>
<p>2、确认好了IP和端口号，则可以向该IP地址对应的服务器的该端口号发起TCP连接请求</p>
<p>3、服务器接收到TCP连接请求后，回复可以连接请求，</p>
<p>4、浏览器收到回传的数据后，还会向服务器发送数据包，表示三次握手结束</p>
<p>5、三次握手成功后，开始通讯，根据HTTP协议的要求，组织一个请求的数据包，里面包含请求的资源路径、你的身份信息等。</p>
<p>例如，<a href="http://www.abc.com/images/1/%E8%A1%A8%E7%A4%BA%E7%9A%84%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E6%98%AFimages/1/%EF%BC%8C%E5%8F%91%E9%80%81%E5%90%8E%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%B0%86%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E7%BB%99%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%E6%98%AF%E6%A0%B9%E6%8D%AEHTML%E5%8D%8F%E8%AE%AE%E7%BB%84%E7%BB%87%E7%9A%84%E7%BD%91%E9%A1%B5%EF%BC%8C%E9%87%8C%E9%9D%A2%E5%8C%85%E5%90%AB%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%B8%83%E5%B1%80%E3%80%81%E6%96%87%E5%AD%97%E7%AD%89%E7%AD%89%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%9B%BE%E7%89%87%E6%88%96%E8%80%85%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%E7%AD%89%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%E6%8C%87%E5%AE%9A%E7%9A%84%E8%B5%84%E6%BA%90%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B0%B1%E4%BC%9A%E8%BF%94%E5%9B%9E404%E9%94%99%E8%AF%AF%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%88%99%E6%A0%B9%E6%8D%AE%E9%A1%B5%E9%9D%A2%E9%87%8C%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A4%96%E9%93%BEURL%E5%9C%B0%E5%9D%80%EF%BC%8C%E9%87%8D%E5%A4%8D%E4%B8%8A%E8%BF%B0%E6%AD%A5%E9%AA%A4%EF%BC%8C%E5%86%8D%E6%AC%A1%E8%8E%B7%E5%8F%96">www.abc.com/images/1/表示的资源路径是images/1/，发送后，服务器响应请求，将数据返回给浏览器，数据可以是根据HTML协议组织的网页，里面包含页面的布局、文字等等，也可以是图片或者脚本程序等，如果资源路径指定的资源不存在，服务器就会返回404错误，如果返回的是一个页面，则根据页面里的一些外链URL地址，重复上述步骤，再次获取</a></p>
<p>6、渲染页面，并开始响应用户的操作</p>
<p>7、窗口关闭时，浏览器终止与服务器的连接</p>
<h2 id="HTTP基础"><a href="#HTTP基础" class="headerlink" title="HTTP基础"></a>HTTP基础</h2><p><strong>超文本传输协议（Hyper Text Transfer Protocol，HTTP）</strong> 是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。</p>
<p>关于HTTP1.1协议的具体内容可以参考<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.2.2">RFC 2616</a>。 </p>
<h3 id="1-报文格式"><a href="#1-报文格式" class="headerlink" title="1. 报文格式"></a>1. 报文格式</h3><p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p>
<p>如下图所示方式可打开HTTP报文查看内容。<br><a href="https://blog.csdn.net/x1037490413/article/details/117704060">http协议以及如何在谷歌控制台查看通信报文</a></p>
<p>上方为请求报文解析内容，下方为响应报文内容。</p>
<p><img src="https://pic.imgdb.cn/item/629440300947543129839d01.png" alt="图1. 一个HTTP报文"></p>
<p><strong>1.1 请求报文格式如下：</strong></p>
<ul>
<li>第一行是包含了请求方法、URL、协议版本；</li>
<li>接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。</li>
<li>一个空行用来分隔首部和内容主体 Body</li>
<li>最后是请求的内容主体</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">http://www.example.com/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br><span class="line"></span><br><span class="line"><span class="language-awk">作者：CyC2018</span></span><br><span class="line"><span class="language-awk">链接：https:<span class="regexp">//</span>leetcode.cn<span class="regexp">/leetbook/</span>read<span class="regexp">/tech-interview-cookbook/</span>orse6h/</span></span><br><span class="line"><span class="language-awk">来源：力扣（LeetCode）</span></span><br></pre></td></tr></table></figure>


<p><strong>1.2 应答报文格式如下：</strong></p>
<ul>
<li>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了，如图1</li>
<li>接下来多行也是首部内容</li>
<li>一个空行分隔首部和内容主体</li>
<li>最后是响应的内容主体</li>
</ul>
<h3 id="2-HTTP-方法"><a href="#2-HTTP-方法" class="headerlink" title="2. HTTP 方法"></a>2. HTTP 方法</h3><p><strong>GET</strong></p>
<p>获取资源</p>
<p><strong>HEAD</strong></p>
<p>获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分。</p>
<p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p>
<p><strong>POST</strong></p>
<p>传输实体主体</p>
<p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p>
<font color = #888888>

<p><em>GET和POST的区别？</em><br>1)	后退按钮或刷新，Get无害，post数据会被重新提交；<br>2)	Get所使用的URL可以被设置为书签，而post不可以；<br>3)	Get能够被缓存，而post不可以；<br>4)	Get参数保留在浏览器历史中，而post参数不会保留在浏览器历史中；<br>5)	当发生数据时，get方法向URL添加数据，URL的数据长度是受限的，而post没有数据长度限制；<br>6)	Get只允许ASCII编码，而post没有限制；<br>7)	Get安全性没有post安全性好；<br>8)	Get数据在URL中对所有人是可见的，而在post中数据不会显示在URL中。<br>9)	Get产生一个TCP数据包，post产生两个TCP数据包；对于get方式的请求，浏览器会把header和data一并发送出去；对于post，浏览器先发送header再发送data；<br>10)	GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器&#x2F;服务器的限制，导致他们在应用过程中体现出一些不同。</p>
</font>


<p><strong>PUT</strong></p>
<p>上传文件</p>
<p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p>
<p><strong>PATCH</strong></p>
<p>对资源进行部分修改</p>
<p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p>
<p><strong>DELETE</strong></p>
<p>删除文件</p>
<p>与 PUT 功能相反，并且同样不带验证机制。</p>
<p><strong>OPTIONS</strong></p>
<p>查询支持的方法</p>
<p>查询指定的 URL 能够支持的方法。</p>
<p>会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。</p>
<p><strong>CONNECT</strong></p>
<p>要求在与代理服务器通信时建立隧道</p>
<p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<p><strong>TRACE</strong></p>
<p>追踪路径</p>
<p>服务器会将通信路径返回给客户端。</p>
<p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p>
<p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p>
<h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">类别</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1XX</td>
<td align="center">Informational（信息性状态码）</td>
<td align="center">接收的请求正在处理</td>
</tr>
<tr>
<td align="center">2XX</td>
<td align="center">Success（成功状态码）</td>
<td align="center">请求正常处理完毕</td>
</tr>
<tr>
<td align="center">3XX</td>
<td align="center">Redirection（重定向状态码）</td>
<td align="center">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td align="center">4XX</td>
<td align="center">Client Error（客户端错误状态码）</td>
<td align="center">服务器无法处理请求</td>
</tr>
<tr>
<td align="center">5XX</td>
<td align="center">Server Error（服务器错误状态码）</td>
<td align="center">服务器处理请求出错</td>
</tr>
</tbody></table>
<p><strong>1. 1XX 信息</strong></p>
<p>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p>
<p><strong>2. 2XX 成功</strong></p>
<p>200 OK</p>
<p>204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p>
<p>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</p>
<p><strong>3. 3XX 重定向</strong></p>
<p>301 Moved Permanently ：永久性重定向</p>
<p>302 Found ：临时性重定向</p>
<p>303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p>
<p><strong>4. 4XX 客户端错误</strong></p>
<p>400 Bad Request ：请求报文中存在语法错误。</p>
<p>401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</p>
<p>403 Forbidden ：请求被拒绝。</p>
<p>404 Not Found</p>
<p><strong>5. 5XX 服务器错误</strong></p>
<p>500 Internal Server Error ：服务器正在执行请求时发生错误。</p>
<p>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://baike.baidu.com/item/HTTP/243074?fr=aladdin">1.百度百科-HTTP</a></p>
<p><a href="https://leetcode.cn/leetbook/read/tech-interview-cookbook/o9ga26/">2.校招基础知识详解-HTTP</a></p>
<p><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.2.2">3.rfc2616：3.2.2 http URL</a></p>
<p><a href="https://blog.csdn.net/x1037490413/article/details/117704060">4.http协议以及如何在谷歌控制台查看通信报文</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>005. UDP/TCP协议详解</title>
    <url>/2022/03/16/005-TCP-IP/</url>
    <content><![CDATA[<p>面试中频繁问到UDP&#x2F;TCP协议，但是经常只知其表，不知其里，因此在这里做一个总结，尽量涵盖可能问到的问题。</p>
<span id="more"></span>

<h2 id="UDP和TCP的特点"><a href="#UDP和TCP的特点" class="headerlink" title="UDP和TCP的特点"></a>UDP和TCP的特点</h2><p><strong>1.	TCP与UDP的区别？应用场景都有哪些？</strong><br>1)	TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>2)	TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。<br>3)	UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。<br>4)	每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5)	TCP对系统资源要求较多，UDP对系统资源要求较少。<br>6)	若通信数据完整性需让位与通信实时性，则应该选用 TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。<br>7)	UDP:DNS   SNMP<br>8)	TCP面向字节流，UTP面向数据包；</p>
<p><strong>2.	为什么UDP有时比TCP更有优势?</strong><br>1)	网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。<br>2)	TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。<br>3)	采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。 </p>
<h2 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h2><p><img src="/images/UDPhead.png" alt="UDP首部格式"><br>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p>
<h2 id="TCP首部格式"><a href="#TCP首部格式" class="headerlink" title="TCP首部格式"></a>TCP首部格式</h2><p><img src="/images/TCPhead.png" alt="TCP首部格式"><br><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
<p><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
<p><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
<p><strong>确认 ACK</strong> ：当 ACK&#x3D;1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
<p><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN&#x3D;1，ACK&#x3D;0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN&#x3D;1，ACK&#x3D;1。</p>
<p><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN&#x3D;1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p>
<p><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
<h2 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h2><p><strong>1.三次握手</strong><br>1)	第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；<br>2)	第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；<br>3)	第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p>
<p><img src="https://pic.imgdb.cn/item/6239213727f86abb2aef1b3b.jpg" alt="TCP的三次握手和四次挥手"></p>
<p><strong>2.四次挥手</strong><br>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。<br>1)	第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；<br>2)	第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；<br>3)	第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；<br>4)	第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。<br>5)	六大标志位<br>SYN，同步标志位；ACK确认标志位；PSH传送标志位；FIN结束标志位；RST重置标志位；URG紧急标志位；seq序号；ack确认号</p>
<h2 id="TCP协议计时器"><a href="#TCP协议计时器" class="headerlink" title="TCP协议计时器"></a>TCP协议计时器</h2><ol>
<li><pre><code>重传计时器
</code></pre>
在一个TCP连接中，TCP每发送一个报文段，就对此报文段设置一个超时重传计时器。若在收到了对此特定报文段的确认之前计时器截止期到，则重传此报文段，并将计时器复位。<ol start="2">
<li><pre><code>持续计时器
</code></pre>
为了对付零窗口大小通知，TCP需要另一个计时器。假定接收TCP宣布了窗口大小为零。发送TCP就停止传送报文段，直到接收TCP发送确认并宣布一个非零的窗口大小。但这个确认可能会丢失。我们知道在TCP中，对确认是不需要发送确认的。若确认丢失了，接收TCP并不知道，而是会认为它已经完成任务了，并等待着发送TCP接着会发送更多的报文段。但发送TCP由于没有收到确认，就等待对方发送确认来通知窗口的大小。双方的TCP都在永远地等待着对方。要打开这种死锁，TCP为每一个连接使用一个坚持计时器。当发送TCP收到一个窗口大小为零的确认时，就启动坚持计时器。当坚持计时器期限到时，发送TCP就发送一个特殊的报文段， 叫做 探测报文段 。这个报文段只有一个字节的数据。它有一个序号，但它的序号永远不需要确认；甚至在计算对其他部分的数据的确认时该序号也被忽略。探测报文段提醒对端：确认已丢失，必须重传。 <ol start="3">
<li><pre><code>保活计时器
</code></pre>
保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时期的空闲。假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远地处理打开状态。 <ol start="4">
<li><pre><code>时间等待计时器
</code></pre>
时间等待计时器是在连接终止期间使用的。当TCP关闭一个连接时，它并不认为这个连接马上就真正地关闭了。在时间等待期间中，连接还处于一种中间过渡状态。这就可以使重复的FIN报文段（如果有的话）可以到达目的站因而可将其丢弃。这个计时器的值通常设置为一个报文段的寿命期待值的两倍。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h2><p><strong>如何保证TCP的可靠传输?</strong><br><strong>1.	序号</strong><br>TCP首部的序号字段用来保证数据能有序提交给应用层，TCP把数据看成无结构的有序的字节流。数据流中的每一个字节都编上一个序号字段的值是指本报文段所发送的数据的第一个字节序号。<br><strong>2.	确认</strong><br>TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号；<br><strong>3.	重传</strong><br>超时重传<br>冗余ACK重传<br><strong>4.	流量控制</strong><br>TCP采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。<br>发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值(可增大或减小)。<br><strong>窗口</strong><br>    接受窗口rwnd，接收端缓冲区大小。接收端将此窗口值放在 TCP 报文的首部中的窗口字段，传送给发送端。<br>    拥塞窗口cwnd，发送缓冲区大小。<br>    发送窗口swnd, 发送窗口的上限值 &#x3D; Min [rwnd, cwnd]</p>
<p><strong>5.	拥塞控制</strong><br><strong>6.	流量控制与拥塞控制的区别</strong><br>所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能承受现有的网络负荷。流量控制往往指的是点对点通信量的控制，是个端到端的问题。流量控制所要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。</p>
<h2 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h2><p><img src="/images/TCPslice_window.png" alt="TCP滑动窗口"><br>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><ol>
<li><pre><code>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。TCP的流量控制是利用滑动窗口机制实现的，接收方在返回的ACK中会包含自己的接收窗口的大小，以控制发送方的数据发送。
</code></pre>
<ol start="2">
<li><pre><code>当某个ACK报文丢失了，就会出现A等待B确认，并且B等待A发送数据的死锁状态。为了解决这种问题，TCP引入了持续计时器（Persistence timer），当A收到rwnd=0时，就启用该计时器，时间到了则发送一个1字节的探测报文，询问B是很忙还是上个ACK丢失了，然后B回应自身的接收窗口大小，返回仍为0（A重设持续计时器继续等待）或者会重发rwnd=x。
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。<br><img src="/images/TCPcontrol1.png" alt="TCP拥塞控制"><br>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p>为了便于讨论，做如下假设：</p>
<p>接收方有足够大的接收缓存，因此不会发生流量控制；<br>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。<br><strong>1.	慢开始</strong><br>发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。<br>当然收到单个确认但此确认多个数据报的时候就加相应的数值。所以一次传输轮次之后拥塞窗口就加倍。这就是乘法增长，和后面的拥塞避免算法的加法增长比较。<br>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：<br>当cwnd&lt;ssthresh时，使用慢开始算法。<br>当cwnd&gt;ssthresh时，改用拥塞避免算法。<br>当cwnd&#x3D;ssthresh时，慢开始与拥塞避免算法任意。<br>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。<br>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如下图：<br><img src="/images/TCPcontrol2.png" alt="TCP慢开始"><br><strong>2.	快重传和快恢复</strong><br>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。<br>快重传配合使用的还有快恢复算法，有以下两个要点:<br>①当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。<br>②考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。如下图：</p>
<p><img src="/images/TCPcontrol3.png" alt="TCP快重传"></p>
<h2 id="time-wait与close-wait"><a href="#time-wait与close-wait" class="headerlink" title="time_wait与close_wait"></a>time_wait与close_wait</h2><h3 id="time-wait"><a href="#time-wait" class="headerlink" title="time_wait"></a>time_wait</h3><p><strong>1.time_wait与close_wait，time_wait状态持续多长时间？为什么会有time_wait状态？</strong><br>1)	time_wait另一边已经初始化一个释放，close_wait连接一端被动关闭；<br>2)	首先调用close()发起主动关闭的一方，在发送最后一个ACK之后会进入time_wait的状态，也就说该发送方会保持2MSL时间之后才会回到初始状态。MSL指的是数据包在网络中的最大生存时间。产生这种结果使得这个TCP连接在2MSL连接等待期间，定义这个连接的四元组（客户端IP地址和端口，服务端IP地址和端口号）不能被使用。<br>3)	为什么存在time_wait</p>
<pre><code>(1) 为实现TCP全双工连接的可靠释放
TCP协议在关闭连接的四次握手过程中，最终的ACK是由主动关闭连接的一端（后面统称A端）发出的，如果这个ACK丢失，对方（后面统称B端）将重发出最终的FIN，因此A端必须维护状态信息（TIME_WAIT）允许它重发最终的ACK。如果A端不维持TIME_WAIT状态，而是处于CLOSED 状态，那么A端将响应RST分节，B端收到后将此分节解释成一个错误。因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的A端必须维持TIME_WAIT状态。
由TCP状态变迁图可知，假设发起主动关闭的一方（client）最后发送的ACK在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前，client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常。

(2) 为使旧的数据包在网络因过期而消失
TCP segment 可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个segment，迷途的segment在路由器修复后也会被送到最终目的地，这个迟到的迷途segment到达时可能会引起问题。在关闭“前一个连接”之后，马上又重新建立起一个相同的IP和端口之间的“新连接”，“前一个连接”的迷途重复分组在“前一个连接”终止后到达，而被“新连接”收到了。为了避免这个情况，TCP协议不允许处于TIME_WAIT状态的连接启动一个新的可用连接，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消逝。
为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。
</code></pre>
<ol start="4">
<li><pre><code>如果time_wait维持的时间过长，主动关闭连接端迟迟无法关闭连接，占用程序资源。
</code></pre>
<ol start="5">
<li><pre><code>如果服务器程序TCP连接一直保持在CLOSE_WAIT状态，那么只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出ack信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。
</code></pre>
<ol start="6">
<li><pre><code>time_wait状态如何避免
</code></pre>
首先服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。</li>
</ol>
</li>
</ol>
</li>
<li>Time_wait为什么是2MSL的时间长度<br>TIME_WAIT的状态是为了等待连接上所有的分组的消失。单纯的想法，发送端只需要等待一个MSL就足够了。这是不够的，假设现在一个MSL的时候，接收端需要发送一个应答，这时候，我们也必须等待这个应答的消失，这个应答的消失也是需要一个MSL，所以我们需要等待2MSL。</li>
</ol>
<h3 id="close-wait"><a href="#close-wait" class="headerlink" title="close_wait"></a>close_wait</h3><ol>
<li><pre><code>产生原因
</code></pre>
在被动关闭连接情况下，在已经接收到FIN，但是还没有发送自己的FIN的时刻，连接处于CLOSE_WAIT状态。通常来讲，CLOSE_WAIT状态的持续时间应该很短，正如SYN_RCVD状态。但是在一些特殊情况下，就会出现连接长时间处于CLOSE_WAIT状态的情况。出现大量close_wait的现象，主要原因是某种情况下对方关闭了socket链接，但是我方忙与读或者写，没有关闭连接。代码需要判断socket，一旦读到0，断开连接，read返回负，检查一下errno，如果不是AGAIN，就断开连接。对方关闭连接之后服务器程序自己没有进一步发出ack信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。<ol start="2">
<li><pre><code>解决方法
</code></pre>
要检测出对方已经关闭的socket，然后关闭它。</li>
</ol>
</li>
</ol>
<h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><p><strong>TCP过程：</strong><br>客户端：<br>　　1、创建socket<br>　　2、绑定ip、端口号到socket字<br>　　3、连接服务器，connect()<br>　　4、收发数据，send()、recv()<br>　　5、关闭连接<br>服务器端：<br>　　1、创建socket字<br>　　2、设置socket属性<br>　　3、绑定ip与端口号<br>　　4、开启监听，listen()<br>　　5、接受发送端的连接accept()<br>　　6、收发数据send()、recv()<br>　　7、关闭网络连接<br>　　8、关闭监听</p>
<p>对应关系：<br>客户端的connect()指向服务器端的accept()<br>客户端、服务器端的send()&#x2F;recv()是双向箭头的关系。</p>
<p><strong>UDP过程：</strong></p>
<p>客户端：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();* 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选<br>　　4、设置对方的IP地址和端口等属性;<br>　　5、发送数据，用函数sendto();<br>　　6、关闭网络连接；<br>服务器端：<br>　　1、创建一个socket，用函数socket()；<br>　　2、设置socket属性，用函数setsockopt();* 可选<br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();<br>　　4、循环接收数据，用函数recvfrom();<br>　　5、关闭网络连接； </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/Anker/p/6210840.html">1.TCP与UDP在socket编程中的区别</a></p>
<p><a href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/oeo4q5/">2.校招基础知识详解-计算机网络传输层协议</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>004. 数据结构总结 —— 树</title>
    <url>/2022/03/02/004-tree-datatype/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><a href="http://c.biancheng.net/view/3390.html">《c语言学习网》数据结构总结——树</a><br>本文旨在根据教程巩固树的数据结构知识和c语言指针的应用，记录一下自己学习过程中的代码，知识讲解参考教程。</p>
<h2 id="一、树的基本概念和术语"><a href="#一、树的基本概念和术语" class="headerlink" title="一、树的基本概念和术语"></a>一、树的基本概念和术语</h2><p>树结构是一种非线性存储结构，存储的是具有“一对多”关系的数据元素的集合。如图 是使用树结构存储的集合 {A,B,C,D,E,F,G,H,I,J,K,L,M} 的示意图。对于数据 A 来说，和数据 B、C、D 有关系；对于数据 B 来说，和 E、F 有关系。这就是“一对多”的关系。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjcvMDk0NDMwMTQ5My0wLnBuZw?x-oss-process=image/format,png" alt="图 1（A）树的示例"></p>
<span id="more"></span>

<h3 id="1-树的节点"><a href="#1-树的节点" class="headerlink" title="1.树的节点"></a>1.树的节点</h3><p>结点：使用树结构存储的每一个数据元素都被称为“结点”。例如，图 1（A）中，数据元素 A 就是一个结点；</p>
<p>父结点（双亲结点）、子结点和兄弟结点：对于图 1（A）中的结点 A、B、C、D 来说，A 是 B、C、D 结点的父结点（也称为“双亲结点”），而 B、C、D 都是 A 结点的子结点（也称“孩子结点”）。对于 B、C、D 来说，它们都有相同的父结点，所以它们互为兄弟结点。</p>
<p>树根结点（简称“根结点”）：每一个非空树都有且只有一个被称为根的结点。图 1（A）中，结点 A 就是整棵树的根结点。</p>
<blockquote>
<p>树根的判断依据为：如果一个结点没有父结点，那么这个结点就是整棵树的根结点。</p>
</blockquote>
<p>叶子结点：如果结点没有任何子结点，那么此结点称为叶子结点（叶结点）。例如图 1（A）中，结点 K、L、F、G、M、I、J 都是这棵树的叶子结点。</p>
<h3 id="2-子树和空树"><a href="#2-子树和空树" class="headerlink" title="2.子树和空树"></a>2.子树和空树</h3><p>子树：如图 1（A）中，整棵树的根结点为结点 A，而如果单看结点 B、E、F、K、L 组成的部分来说，也是棵树，而且节点 B 为这棵树的根结点。所以称 B、E、F、K、L 这几个结点组成的树为整棵树的子树；同样，结点 E、K、L 构成的也是一棵子树，根结点为 E。</p>
<blockquote>
<p>注意：单个结点也是一棵树，只不过根结点就是它本身。图 1（A）中，结点 K、L、F 等都是树，且都是整棵树的子树。</p>
</blockquote>
<p>知道了子树的概念后，树也可以这样定义：树是由根结点和若干棵子树构成的。</p>
<p>空树：如果集合本身为空，那么构成的树就被称为空树。空树中没有结点。</p>
<blockquote>
<p>补充：在树结构中，对于具有同一个根结点的各个子树，相互之间不能有交集。例如，图 1（A）中，除了根结点<br>A，其余元素又各自构成了三个子树，根结点分别为 B、C、D，这三个子树相互之间没有相同的结点。如果有，就破坏了树的结构，不能算做是一棵树。</p>
</blockquote>
<h3 id="3-结点的度和层次"><a href="#3-结点的度和层次" class="headerlink" title="3.结点的度和层次"></a>3.结点的度和层次</h3><p>对于一个结点，拥有的子树数（结点有多少分支）称为结点的度（Degree）。例如，图 1（A）中，根结点 A 下分出了 3 个子树，所以，结点 A 的度为 3。</p>
<blockquote>
<p>一棵树的度是树内各结点的度的最大值。图 1（A）表示的树中，各个结点的度的最大值为 3，所以，整棵树的度的值是 3。</p>
</blockquote>
<p>结点的层次：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。对于图 1（A）来说，A 结点在第一层，B、C、D 为第二层，E、F、G、H、I、J 在第三层，K、L、M 在第四层。</p>
<blockquote>
<p>一棵树的深度（高度）是树中结点所在的最大的层次。图 1（A）树的深度为 4。</p>
</blockquote>
<p>如果两个结点的父结点虽不相同，但是它们的父结点处在同一层次上，那么这两个结点互为堂兄弟。例如，图 1（A）中，结点 G 和 E、F、H、I、J 的父结点都在第二层，所以之间为堂兄弟的关系。</p>
<h3 id="4-有序树和无序树"><a href="#4-有序树和无序树" class="headerlink" title="4.有序树和无序树"></a>4.有序树和无序树</h3><p>如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树。</p>
<blockquote>
<p>在有序树中，一个结点最左边的子树称为”第一个孩子”，最右边的称为”最后一个孩子”。</p>
</blockquote>
<p>拿图 1（A）来说，如果是其本身是一棵有序树，则以结点 B 为根结点的子树为整棵树的第一个孩子，以结点 D 为根结点的子树为整棵树的最后一个孩子。</p>
<h3 id="5-森林"><a href="#5-森林" class="headerlink" title="5.森林"></a>5.森林</h3><p>由 m（m &gt;&#x3D; 0）个互不相交的树组成的集合被称为森林。图 1（A）中，分别以 B、C、D 为根结点的三棵子树就可以称为森林。</p>
<p>前面讲到，树可以理解为是由根结点和若干子树构成的，而这若干子树本身是一个森林，所以，树还可以理解为是由根结点和森林组成的。用一个式子表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; Tree =（root,F）</span><br></pre></td></tr></table></figure>

<p>其中，root 表示树的根结点，F 表示由 m（m &gt;&#x3D; 0）棵树组成的森林。</p>
<h2 id="二、二叉树及其性质"><a href="#二、二叉树及其性质" class="headerlink" title="二、二叉树及其性质"></a>二、二叉树及其性质</h2><p>简单地理解，满足以下两个条件的树就是二叉树：<br>1.本身是有序树；<br>2.树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；<br>例如，图 1 a) 就是一棵二叉树，而图 1 b) 则不是。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjcvMDk0NTJMUjEtMC5naWY" alt="图 2 a)  二叉树"></p>
<h3 id="1-二叉树的性质"><a href="#1-二叉树的性质" class="headerlink" title="1.二叉树的性质"></a>1.二叉树的性质</h3><p>二叉树具有以下几个性质：<br>1.二叉树中，第 i 层最多有 2^i-1^ 个结点。<br>2.如果二叉树的深度为 K，那么此二叉树最多有 2^K^-1 个结点。<br>3.二叉树中，终端结点数（叶子结点数）为 n<del>0</del>，度为 2 的结点数为 n<del>2</del>，则 n<del>0</del>&#x3D;n<del>2</del>+1。</p>
<blockquote>
<p>性质 3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点<br>n&#x3D;n<del>0</del>+n<del>1</del>+n<del>2</del>。 同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n&#x3D;B+1。而分枝数是可以通过<br>n<del>1</del> 和 n<del>2</del> 表示的，即 B&#x3D;n<del>1</del>+2<em>n<del>2</del>。所以，n 用另外一种方式表示为 n&#x3D;n<del>1</del>+2</em>n<del>2</del>+1。 两种方式得到的 n<br>值组成一个方程组，就可以得出 n<del>0</del>&#x3D;n<del>2</del>+1。</p>
</blockquote>
<p>二叉树还可以继续分类，衍生出满二叉树和完全二叉树。</p>
<h3 id="2-满二叉树"><a href="#2-满二叉树" class="headerlink" title="2.满二叉树"></a>2.满二叉树</h3><p>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。</p>
<p>满二叉树示意图</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjcvMDk0NTJIRzgtMS5naWY" alt="在这里插入图片描述"><br>图 2 满二叉树示意图</p>
<p>如图 2 所示就是一棵满二叉树。</p>
<p>满二叉树除了满足普通二叉树的性质，还具有以下性质：<br>满二叉树中第 i 层的节点数为 2^n-1^ 个。<br>深度为 k 的满二叉树必有 2^k-1^ 个节点 ，叶子数为 2^k-1^。<br>满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。<br>具有 n 个节点的满二叉树的深度为 log<del>2</del>(n+1)。</p>
<h3 id="3-完全二叉树"><a href="#3-完全二叉树" class="headerlink" title="3.完全二叉树"></a>3.完全二叉树</h3><p>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。</p>
<p>完全二叉树示意图</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjcvMDk0NTJNYjUtMi5naWY" alt="在这里插入图片描述"><br>图 3 完全二叉树示意图</p>
<p>如图 3a) 所示是一棵完全二叉树，图 3b) 由于最后一层的节点没有按照从左向右分布，因此只能算作是普通的二叉树。</p>
<p>完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log<del>2</del>n⌋+1。</p>
<blockquote>
<p>⌊log<del>2</del>n⌋ 表示取小于 log<del>2</del>n 的最大整数。例如，⌊log<del>2</del>4⌋ &#x3D; 2，而 ⌊log<del>2</del>5⌋ 结果也是 2。</p>
</blockquote>
<p>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：<br>当 i&gt;1 时，父亲结点为结点 [i&#x2F;2] 。（i&#x3D;1 时，表示的是根结点，无父亲结点）<br>如果 2<em>i&gt;n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2</em>i 。<br>如果 2<em>i+1&gt;n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2</em>i+1 。</p>
<h2 id="三、树的存储结构"><a href="#三、树的存储结构" class="headerlink" title="三、树的存储结构"></a>三、树的存储结构</h2><h3 id="1-二叉树的顺序存储"><a href="#1-二叉树的顺序存储" class="headerlink" title="1.二叉树的顺序存储"></a>1.二叉树的顺序存储</h3><p>二叉树的顺序存储，指的是使用顺序表（数组）存储二叉树。<strong>注：顺序存储只适用于完全二叉树。</strong></p>
<blockquote>
<p> 如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。如下图所示：</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjcvMDk0NjI0TTAyLTAucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可。<br>比如上面的图2，存储结构如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjcvMDk0NjI0RjA0LTMucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>普通二叉树使用顺序表存储或多或多会存在空间浪费的现象，因此引入下面的链式存储。</p>
<h3 id="2-二叉树的链式存储"><a href="#2-二叉树的链式存储" class="headerlink" title="2.二叉树的链式存储"></a>2.二叉树的链式存储</h3><p>二叉树链式存储结构示意图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjcvMDk0R0oyWi0xLmdpZg" alt="在这里插入图片描述"><br>采用链式存储二叉树时，其节点结构由 3 部分构成（如图所示）：<br>指向左孩子节点的指针（Lchild）；<br>节点存储的数据（data）；<br>指向右孩子节点的指针（Rchild）；<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjcvMDk0R0swMzQtMi5naWY" alt="在这里插入图片描述"><br>数据结构为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>
<p>下面是一段完整的c语言代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELEMTYPE int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Struct of binary tree node</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	ELEMTYPE data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//child node pointer</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">parent</span>;</span><span class="comment">//parent node pointer</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	create a tree</span></span><br><span class="line"><span class="comment">*Input:		Bitree</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">createTree</span><span class="params">(BiTree *T)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Tree Graph:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1:       1		\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;        /\\		\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2:     2  3		\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;      /			\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3:   4			\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 1</span></span><br><span class="line">	*T = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;data = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 2</span></span><br><span class="line">	(*T)-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;lchild-&gt;data = <span class="number">2</span>;</span><br><span class="line">	(*T)-&gt;lchild-&gt;parent = *T;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;rchild-&gt;data = <span class="number">3</span>;</span><br><span class="line">	(*T)-&gt;rchild-&gt;parent = *T;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 3</span></span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;data = <span class="number">4</span>;</span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;parent = (*T)-&gt;lchild;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 4</span></span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	BiTree tree;</span><br><span class="line">	createTree(&amp;tree);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Root is:%d\n&quot;</span>,tree-&gt;data);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Parent of the fourth node is:%d\n&quot;</span>, tree-&gt;lchild-&gt;lchild-&gt;parent-&gt;data);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>三叉链表</strong>：在某些实际场景中，可能会做 “查找某节点的父节点” 的操作，这时可以在节点结构中再添加一个指针域，用于各个节点指向其父亲节点。</p>
<h2 id="四、先序遍历"><a href="#四、先序遍历" class="headerlink" title="四、先序遍历"></a>四、先序遍历</h2><p>二叉树先序遍历的实现思想是：<br>1.访问根节点；<br>2.访问当前节点的左子树；<br>3.若当前节点无左子树，则访问当前节点的右子树；<br>如图所示二叉树：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjcvMDk0VDY0NEItMC5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<h3 id="递归方法："><a href="#递归方法：" class="headerlink" title="递归方法："></a>递归方法：</h3><p>二叉树的先序遍历采用的是递归的思想，因此可以递归实现，其 C 语言实现代码为（完整代码见非递归）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Preorder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		Visit(T);</span><br><span class="line">		Preorder(T-&gt;lchild);</span><br><span class="line">		Preorder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非递归方法："><a href="#非递归方法：" class="headerlink" title="非递归方法："></a>非递归方法：</h3><p>而递归的底层实现依靠的是栈存储结构，因此，二叉树的先序遍历既可以直接采用递归思想实现，也可以使用栈的存储结构模拟递归的思想实现，思路如下：<br>1.对于每个节点判断是否有左右节点，<br>2.如果有左节点则继续访问左孩子节点，并判断其是否有右节点，如果有则入栈，没有则忽略。<br>3.如果当前节点没有左孩子节点，则继续判断栈是否有元素，如果有则回到栈节点继续访问右子树。如果没有则前序遍历完成。</p>
<p>其 C 语言实现代码为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELEMTYPE int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//Struct of binary tree node</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	ELEMTYPE data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//child node pointer</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	create a tree</span></span><br><span class="line"><span class="comment">*Input:		Bitree</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateTree</span><span class="params">(BiTree *T)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Tree Graph:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1:       1		\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;        /\\		\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2:     2  3		\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;      /\\  /\\ 	\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3:   4 5  6 7	\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 1</span></span><br><span class="line">	*T = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;data = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 2</span></span><br><span class="line">	(*T)-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;lchild-&gt;data = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;rchild-&gt;data = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 3</span></span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;data = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild-&gt;data = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild-&gt;data = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild-&gt;data = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 4</span></span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	visit a node</span></span><br><span class="line"><span class="comment">*Input:		BiTNode</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Visit</span><span class="params">(BiTNode *T)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Preorder:%d\n&quot;</span>, T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	preorder visit a tree</span></span><br><span class="line"><span class="comment">*Input:		Bitree</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Preorder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		Visit(T);</span><br><span class="line">		Preorder(T-&gt;lchild);</span><br><span class="line">		Preorder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	pop</span></span><br><span class="line"><span class="comment">*Input:		BiTNode*[]</span></span><br><span class="line"><span class="comment">*return		BiTNode*--The top element of stack.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BiTNode* <span class="title function_">pop</span><span class="params">(BiTNode* Stack[])</span> &#123;</span><br><span class="line">	BiTNode* a = Stack[top--];</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	push</span></span><br><span class="line"><span class="comment">*Input:		BiTNode*[], BiTNode*</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(BiTNode* Stack[], BiTNode* a)</span> &#123;</span><br><span class="line">	Stack[++top] = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	preorder visit a tree by using a stack</span></span><br><span class="line"><span class="comment">*Input:		Bitree</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreorderStack</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">	BiTNode* Stack[MAXSIZE];<span class="comment">//Initialize the stack</span></span><br><span class="line">	<span class="keyword">while</span> (T) &#123;</span><br><span class="line">		Visit(T);</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;lchild) &#123;<span class="comment">//If T has left child</span></span><br><span class="line">			<span class="keyword">if</span> (T-&gt;rchild) &#123;	<span class="comment">//If T has left and right child</span></span><br><span class="line">				push(Stack,T-&gt;rchild);</span><br><span class="line">			&#125;</span><br><span class="line">			T = T-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;rchild)&#123;<span class="comment">//If T only has right child</span></span><br><span class="line">			T = T-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(top&gt;=<span class="number">0</span>)&#123;<span class="comment">//If Stack has elements</span></span><br><span class="line">			BiTNode *a = pop(Stack);</span><br><span class="line">			T = a;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//If T is last node in preorder.</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	BiTree tree;</span><br><span class="line">	CreateTree(&amp;tree);</span><br><span class="line">	<span class="comment">//recursive</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Recursive PreOrder\n&quot;</span>);</span><br><span class="line">	Preorder(tree);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//not recursive</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Non-recursive PreOrder\n&quot;</span>);</span><br><span class="line">	PreorderStack(tree);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="五、中序遍历"><a href="#五、中序遍历" class="headerlink" title="五、中序遍历"></a>五、中序遍历</h2><p>二叉树中序遍历的实现思想是：<br>1.访问当前节点的左子树；<br>2.访问根节点；<br>3.访问当前节点的右子树；</p>
<p>如图所示二叉树：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjcvMDk0VDY0NEItMC5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><p>二叉树的中序遍历采用的是递归的思想，因此可以递归实现，其 C 语言实现代码为（完整代码见非递归方法）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	InOrder visit a tree</span></span><br><span class="line"><span class="comment">*Input:		Bitree</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		InOrder(T-&gt;lchild);</span><br><span class="line">		Visit(T);</span><br><span class="line">		InOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归方法"><a href="#非递归方法" class="headerlink" title="非递归方法"></a>非递归方法</h3><p>我的思路如下：<br>访问根节点，判断其是否有左右孩子。<br>如果有左孩子，则根节点入栈，继续访问左子树。如果左子树为空，则访问出栈元素，然后访问其右子树。<br>如果没有左孩子，则判断是否有右孩子，并访问当前节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELEMTYPE int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//Struct of binary tree node</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	ELEMTYPE data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//child node pointer</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	create a tree</span></span><br><span class="line"><span class="comment">*Input:		Bitree</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateTree</span><span class="params">(BiTree *T)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Tree Graph:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1:       1		\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;        /\\		\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2:     2  3		\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;      /\\  /\\ 	\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3:   4 5  6 7	\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 1</span></span><br><span class="line">	*T = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;data = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 2</span></span><br><span class="line">	(*T)-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;lchild-&gt;data = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;rchild-&gt;data = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 3</span></span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;data = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild-&gt;data = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild-&gt;data = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild-&gt;data = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 4</span></span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	visit a node</span></span><br><span class="line"><span class="comment">*Input:		BiTNode</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Visit</span><span class="params">(BiTNode *T)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;InOrder:%d\n&quot;</span>, T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	InOrder visit a tree</span></span><br><span class="line"><span class="comment">*Input:		Bitree</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		InOrder(T-&gt;lchild);</span><br><span class="line">		Visit(T);</span><br><span class="line">		InOrder(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	pop</span></span><br><span class="line"><span class="comment">*Input:		BiTNode*[]</span></span><br><span class="line"><span class="comment">*return		BiTNode*--The top element of stack.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BiTNode* <span class="title function_">pop</span><span class="params">(BiTNode* Stack[])</span> &#123;</span><br><span class="line">	BiTNode* a = Stack[top--];</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	push</span></span><br><span class="line"><span class="comment">*Input:		BiTNode*[], BiTNode*</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(BiTNode* Stack[], BiTNode* a)</span> &#123;</span><br><span class="line">	Stack[++top] = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	InOrder visit a tree by using a stack</span></span><br><span class="line"><span class="comment">*Input:		Bitree</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderStack</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">	BiTNode* Stack[MAXSIZE];<span class="comment">//Initialize the stack</span></span><br><span class="line">	<span class="keyword">while</span> (T) &#123;</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;lchild) &#123;<span class="comment">//If T has left child</span></span><br><span class="line">			push(Stack, T);</span><br><span class="line">			T = T-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Visit(T);</span><br><span class="line">			<span class="keyword">if</span> (T-&gt;rchild) &#123;<span class="comment">//If T has right child</span></span><br><span class="line">				T = T-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (top &gt;= <span class="number">0</span>) &#123;<span class="comment">//If Stack has elements</span></span><br><span class="line">				BiTNode *a = pop(Stack);</span><br><span class="line">				Visit(a);</span><br><span class="line">				T = a-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//If T is last node in preorder.</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	BiTree tree;</span><br><span class="line">	CreateTree(&amp;tree);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Recursive InOrder\n&quot;</span>);</span><br><span class="line">	<span class="comment">//recursive</span></span><br><span class="line">	InOrder(tree);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Non-recursive InOrder\n&quot;</span>);</span><br><span class="line">	<span class="comment">//not recursive</span></span><br><span class="line">	InOrderStack(tree);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种更标准的方法如下：<br>中序遍历的非递归方式实现思想是：从根结点开始，遍历左孩子同时压栈，当遍历结束，说明当前遍历的结点没有左孩子，从栈中取出来调用操作函数，然后访问该结点的右孩子，继续以上重复性的操作。</p>
<p>除此之外，还有另一种实现思想：中序遍历过程中，只需将每个结点的左子树压栈即可，右子树不需要压栈。当结点的左子树遍历完成后，只需要以栈顶结点的右孩子为根结点，继续循环遍历即可。</p>
<h2 id="六、后序遍历"><a href="#六、后序遍历" class="headerlink" title="六、后序遍历"></a>六、后序遍历</h2><p>二叉树中序遍历的实现思想是：<br>1.访问当前节点的左子树；<br>2.访问当前节点的右子树；<br>3.访问根节点；</p>
<p>如图所示二叉树：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjcvMDk0VDY0NEItMC5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<h3 id="递归方法-1"><a href="#递归方法-1" class="headerlink" title="递归方法"></a>递归方法</h3><p>二叉树的后序遍历采用的是递归的思想，因此可以递归实现，其 C 语言实现代码为（完整代码见非递归方法）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	Recursive method to traverse a tree in post-order</span></span><br><span class="line"><span class="comment">*Input:		Bitree</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(<span class="type">const</span> BiTree T)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		PostOrder(T-&gt;lchild);</span><br><span class="line">		PostOrder(T-&gt;rchild);</span><br><span class="line">		Visit(T);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归方法-1"><a href="#非递归方法-1" class="headerlink" title="非递归方法"></a>非递归方法</h3><p>非递归算法的思路是：<br>后序遍历的逆序 是 先序遍历交换左右子树遍历顺序。<br>因此用两个栈来实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELEMTYPE int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> top = <span class="number">-1</span>;   <span class="comment">//index of stack</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> printtop = <span class="number">-1</span>; <span class="comment">//index of printstack</span></span><br><span class="line"><span class="comment">//Struct of binary tree node</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	ELEMTYPE data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//child node pointer</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	create a tree</span></span><br><span class="line"><span class="comment">*Input:		Bitree</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateTree</span><span class="params">(BiTree *T)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Tree Graph:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1:       1		\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;        /\\		\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2:     2  3		\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;      /\\  /\\ 	\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3:   4 5  6 7	\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 1</span></span><br><span class="line">	*T = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;data = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 2</span></span><br><span class="line">	(*T)-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;lchild-&gt;data = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;rchild-&gt;data = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 3</span></span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;data = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild-&gt;data = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild-&gt;data = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild-&gt;data = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 4</span></span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	visit a node</span></span><br><span class="line"><span class="comment">*Input:		BiTNode</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Visit</span><span class="params">(BiTNode *T)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;PostOrder:%d\n&quot;</span>, T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	Recursive method to traverse a tree in post-order</span></span><br><span class="line"><span class="comment">*Input:		Bitree</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(<span class="type">const</span> BiTree T)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		PostOrder(T-&gt;lchild);</span><br><span class="line">		PostOrder(T-&gt;rchild);</span><br><span class="line">		Visit(T);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	pop</span></span><br><span class="line"><span class="comment">*Input:		BiTNode*[]</span></span><br><span class="line"><span class="comment">*return		BiTNode*--The top element of stack.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BiTNode* <span class="title function_">pop</span><span class="params">(BiTNode* Stack[])</span> &#123;</span><br><span class="line">	BiTNode* a = Stack[top--];</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	push</span></span><br><span class="line"><span class="comment">*Input:		BiTNode*[], BiTNode*</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(BiTNode* Stack[], BiTNode* a)</span> &#123;</span><br><span class="line">	Stack[++top] = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	printpop for printstack</span></span><br><span class="line"><span class="comment">*Input:		BiTNode*[]</span></span><br><span class="line"><span class="comment">*return		BiTNode*--The top element of stack.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BiTNode* <span class="title function_">printpop</span><span class="params">(BiTNode* Stack[])</span> &#123;</span><br><span class="line">	BiTNode* a = Stack[printtop--];</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	printpush for printstack</span></span><br><span class="line"><span class="comment">*Input:		BiTNode*[], BiTNode*</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printpush</span><span class="params">(BiTNode* Stack[], BiTNode* a)</span> &#123;</span><br><span class="line">	Stack[++printtop] = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	PostOrder visit a tree by using two stacks</span></span><br><span class="line"><span class="comment">*Input:		Bitree</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderStack</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">	BiTNode* Stack[MAXSIZE];<span class="comment">//Initialize the stack</span></span><br><span class="line">	BiTNode* PrintStack[MAXSIZE];<span class="comment">//Initialize the stack</span></span><br><span class="line">	<span class="keyword">while</span> (T) &#123;</span><br><span class="line">		printpush(PrintStack, T);</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;rchild) &#123;<span class="comment">//If T has left child</span></span><br><span class="line">			<span class="keyword">if</span> (T-&gt;lchild) &#123;	<span class="comment">//If T has left and right child</span></span><br><span class="line">				push(Stack, T-&gt;lchild);</span><br><span class="line">			&#125;</span><br><span class="line">			T = T-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;lchild) &#123;<span class="comment">//If T only has right child</span></span><br><span class="line">			T = T-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (top &gt;= <span class="number">0</span>) &#123;<span class="comment">//If Stack has elements</span></span><br><span class="line">			BiTNode *a = pop(Stack);</span><br><span class="line">			T = a;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//If T is last node in preorder.</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (printtop &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		Visit(printpop(PrintStack));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	BiTree tree;</span><br><span class="line">	CreateTree(&amp;tree);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Recursive method\n&quot;</span>);</span><br><span class="line">	<span class="comment">//Recursive method to traverse a tree in post-order</span></span><br><span class="line">	PostOrder(tree);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Non-recursive method\n&quot;</span>);</span><br><span class="line">	<span class="comment">//Non-recursive method to traverse a tree in post-order</span></span><br><span class="line">	PostOrderStack(tree);</span><br><span class="line">	getchar();</span><br><span class="line">	delete tree;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种算法思路：<br>用一个栈，但是设置标志位。<br>后序遍历是在遍历完当前结点的左右孩子之后，才调用操作函数，所以需要在操作结点进栈时，为每个结点配备一个标志位。当遍历该结点的左孩子时，设置当前结点的标志位为 0，进栈；当要遍历该结点的右孩子时，设置当前结点的标志位为 1，进栈。</p>
<p>这样，当遍历完成，该结点弹栈时，查看该结点的标志位的值：如果是 0，表示该结点的右孩子还没有遍历；反之如果是 1，说明该结点的左右孩子都遍历完成，可以调用操作函数。<br><a href="http://c.biancheng.net/view/3390.html">代码实现</a></p>
<h2 id="七、层次遍历"><a href="#七、层次遍历" class="headerlink" title="七、层次遍历"></a>七、层次遍历</h2><p>按照二叉树中的层次从左到右依次遍历每层中的结点。<br>具体的实现思路是：通过使用队列的数据结构，从树的根结点开始，依次将其左孩子和右孩子入队。而后每次队列中一个结点出队，都将其左孩子和右孩子入队，直到树中所有结点都出队，出队结点的先后顺序就是层次遍历的最终结果。</p>
<p>如图1所示二叉树：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjcvMDk0VDY0NEItMC5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>例如，层次遍历图 1 中的二叉树：<br>首先，根结点 1 入队；<br>根结点 1 出队，出队的同时，将左孩子 2 和右孩子 3 分别入队；<br>队头结点 2 出队，出队的同时，将结点 2 的左孩子 4 和右孩子 5 依次入队；<br>队头结点 3 出队，出队的同时，将结点 3 的左孩子 6 和右孩子 7 依次入队；<br>不断地循环，直至队列内为空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELEMTYPE int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//Struct of binary tree node</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	ELEMTYPE data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//child node pointer</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	create a tree</span></span><br><span class="line"><span class="comment">*Input:		Bitree</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateTree</span><span class="params">(BiTree *T)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Tree Graph:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1:       1		\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;        /\\		\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2:     2  3		\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;      /\\  /\\ 	\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3:   4 5  6 7	\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 1</span></span><br><span class="line">	*T = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;data = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 2</span></span><br><span class="line">	(*T)-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;lchild-&gt;data = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;rchild-&gt;data = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 3</span></span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;data = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild-&gt;data = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild-&gt;data = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild-&gt;data = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Depth: 4</span></span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;lchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;lchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;rchild-&gt;lchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">	(*T)-&gt;rchild-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	visit a node</span></span><br><span class="line"><span class="comment">*Input:		BiTNode</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Visit</span><span class="params">(BiTNode *T)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hierarchical traversal:%d\n&quot;</span>, T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(BiTNode * <span class="built_in">queue</span>[],BiTNode * a)</span> &#123;</span><br><span class="line">	<span class="built_in">queue</span>[rear++] = a;</span><br><span class="line">&#125;</span><br><span class="line">BiTNode * <span class="title function_">DeQueue</span><span class="params">(BiTNode * <span class="built_in">queue</span>[])</span> &#123;</span><br><span class="line">	BiTNode *b = <span class="built_in">queue</span>[front++];</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	Hierarchical traversal</span></span><br><span class="line"><span class="comment">*Input:		Bitree</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hierarchical</span><span class="params">(<span class="type">const</span> BiTree T)</span> &#123;</span><br><span class="line">	BiTNode* Queue[MAXSIZE];</span><br><span class="line">	BiTree q = T;</span><br><span class="line">	EnQueue(Queue,q);</span><br><span class="line">	<span class="keyword">while</span> (front&lt;rear) &#123;</span><br><span class="line">		BiTNode* node = DeQueue(Queue);</span><br><span class="line">		Visit(node);</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;lchild!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">			EnQueue(Queue, node-&gt;lchild);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			EnQueue(Queue, node-&gt;rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	BiTree tree;</span><br><span class="line">	CreateTree(&amp;tree);</span><br><span class="line">	<span class="comment">//Hierarchical traversal</span></span><br><span class="line">	Hierarchical(tree);</span><br><span class="line">	getchar();</span><br><span class="line">	delete tree;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、哈夫曼树"><a href="#八、哈夫曼树" class="headerlink" title="八、哈夫曼树"></a>八、哈夫曼树</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。</p>
<p>路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。</p>
<p>结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。</p>
<p>结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 &#x3D; 10 </p>
<p><img src="https://img-blog.csdn.net/20131205224108125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd3RmbW9ua2luZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="在这里插入图片描述"></p>
<p>哈夫曼树：又称最优二叉树。它是 n 个带权叶子结点构成的所有二叉树中，带权路径长度 WPL 最小的二叉树。<br>如下图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjcvMDk1NjNUYjAtMC5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<h3 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h3><p>对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：<br>在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；<br>在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；<br>重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjcvMDk1NjNRUzUtMS5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<h3 id="哈弗曼树中结点结构"><a href="#哈弗曼树中结点结构" class="headerlink" title="哈弗曼树中结点结构"></a>哈弗曼树中结点结构</h3><p>构建哈夫曼树时，首先需要确定树中结点的构成。由于哈夫曼树的构建是从叶子结点开始，不断地构建新的父结点，直至树根，所以结点中应包含指向父结点的指针。但是在使用哈夫曼树时是从树根开始，根据需求遍历树中的结点，因此每个结点需要有指向其左孩子和右孩子的指针。</p>
<p>所以，哈夫曼树中结点构成用代码表示为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Struct of huffman tree</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">	ELEMTYPE data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">left</span>, *<span class="title">right</span>;</span><span class="comment">//child node pointer</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">parent</span>;</span><span class="comment">//child node pointer</span></span><br><span class="line">&#125;BTNode, *HFTree;</span><br></pre></td></tr></table></figure>
<h3 id="构建哈弗曼树的算法实现及WPL的计算"><a href="#构建哈弗曼树的算法实现及WPL的计算" class="headerlink" title="构建哈弗曼树的算法实现及WPL的计算"></a>构建哈弗曼树的算法实现及WPL的计算</h3><p>构建哈夫曼树时，需要每次根据各个结点的权重值，筛选出其中值最小的两个结点，然后构建二叉树。</p>
<p>大佬的思路：查找权重值最小的两个结点的思想是：从树组起始位置开始，首先找到两个无父结点的结点（说明还未使用其构建成树），然后和后续无父结点的结点依次做比较，有两种情况需要考虑：<br>如果比两个结点中较小的那个还小，就保留这个结点，删除原来较大的结点；<br>如果介于两个结点权重值之间，替换原来较大的结点；<br>参考：<a href="https://blog.csdn.net/wtfmonking/article/details/17150499">哈夫曼树c语言实现</a><br>我的思路：<br>建立一个哈夫曼树：<br>创建工作指针p+tmp，<br>对于一组数，依次找出最小的数加入树中(选择排序思想)，<br>如果树没有创建，则创建一个结点存入第一个数。工作指针指向这个结点<br>如果工作指针没有左孩子，则工作指针左孩子指向下一个结点<br>如果工作指针没有右孩子，则工作指针右孩子指向下一个结点<br>如果工作指针有两个孩子，则创建一个空结点，左孩子指向工作指针，右孩子指向下一个结点，并将工作指针指向该结点。<br>计算wpl:<br>递归计算，<br>如果结点没有左右孩子则为叶子结点，返回权值*高度.<br>如果有孩子，则返回左子树wpl和右子树wpl之和.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELEMTYPE int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> top = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//Struct of huffman tree</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">	ELEMTYPE data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">left</span>, *<span class="title">right</span>;</span><span class="comment">//child node pointer</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">parent</span>;</span><span class="comment">//child node pointer</span></span><br><span class="line">&#125;BTNode, *HFTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	create a huffman tree</span></span><br><span class="line"><span class="comment">*Input:		int *nums--numbers to create tree,int n--num[] size</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HFTree <span class="title function_">CreateTree</span><span class="params">(<span class="type">int</span> *nums,<span class="type">int</span> n)</span> &#123;</span><br><span class="line">	BTNode *p_tmp =(BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode)); <span class="comment">//work pointer</span></span><br><span class="line">	p_tmp-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">	p_tmp-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">	p_tmp-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> lastnum = <span class="number">0</span>;<span class="comment">//Initilize with a num less than the min num</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> min = <span class="number">100</span>;<span class="comment">//Initilize with a num larger than the max num</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (min&gt;nums[j] &amp;&amp; lastnum&lt;nums[j]) &#123;</span><br><span class="line">				min = nums[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		lastnum = min;</span><br><span class="line">		<span class="comment">//create a new node</span></span><br><span class="line">		BTNode *p_newchild= (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">		p_newchild-&gt;data = min;</span><br><span class="line">		p_newchild-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">		p_newchild-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">		p_newchild-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> == n) &#123;</span><br><span class="line">			<span class="keyword">return</span> p_newchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (p_tmp-&gt;left==<span class="literal">NULL</span>) &#123; <span class="comment">//add node to left of p_tmp</span></span><br><span class="line">			p_tmp-&gt;left = p_newchild;</span><br><span class="line">			p_newchild-&gt;parent = p_tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(p_tmp-&gt;right == <span class="literal">NULL</span>)&#123;<span class="comment">//add node to right of p_tmp</span></span><br><span class="line">			p_tmp-&gt;right = p_newchild;</span><br><span class="line">			p_tmp-&gt;data = p_tmp-&gt;left-&gt;data + p_tmp-&gt;right-&gt;data;</span><br><span class="line">			p_newchild-&gt;parent =p_tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//add brother node of p_tmp and create p_newparent</span></span><br><span class="line">			BTNode *p_newparent = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">			p_newparent-&gt;data = p_tmp-&gt;data+min;</span><br><span class="line">			<span class="keyword">if</span> (p_tmp-&gt;data&lt;=min) &#123;</span><br><span class="line">				p_newparent-&gt;left = p_tmp;</span><br><span class="line">				p_newparent-&gt;right = p_newchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				p_newparent-&gt;left = p_newchild;</span><br><span class="line">				p_newparent-&gt;right = p_tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			p_newparent-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">			p_newchild-&gt;parent = p_newparent;</span><br><span class="line">			p_tmp = p_newparent;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p_tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	visit a node</span></span><br><span class="line"><span class="comment">*Input:		BiTNode</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Visit</span><span class="params">(BTNode *T)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;PreOrder:%d\n&quot;</span>, T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	PreOrder visit a tree</span></span><br><span class="line"><span class="comment">*Input:		Bitree</span></span><br><span class="line"><span class="comment">*return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(HFTree T)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		Visit(T);</span><br><span class="line">		PreOrder(T-&gt;left);</span><br><span class="line">		PreOrder(T-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*Function:	calculate the weight path length of HFTree</span></span><br><span class="line"><span class="comment">*Input:		HFTree T, int len--depth</span></span><br><span class="line"><span class="comment">*return		wpl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cal_wpl</span><span class="params">(HFTree T, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		<span class="comment">//If leaf node</span></span><br><span class="line">		<span class="keyword">if</span> (T-&gt;left==<span class="literal">NULL</span> &amp;&amp; T-&gt;right==<span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> T-&gt;data*len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//If not leaf node, return left child tree wpl and right child tree wpl</span></span><br><span class="line">			<span class="keyword">return</span> cal_wpl(T-&gt;left,len+<span class="number">1</span>) + cal_wpl(T-&gt;left,len+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Null tree return 0;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> nums[<span class="number">5</span>] = &#123;<span class="number">9</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">18</span>&#125;;</span><br><span class="line">	HFTree tree=CreateTree(nums,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//recursive visit tree node</span></span><br><span class="line">	PreOrder(tree);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cal_wpl(tree,<span class="number">0</span>));</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>003. go入门，学习用goroutine开启并发</title>
    <url>/2022/03/02/003-goroutine/</url>
    <content><![CDATA[<p><strong>为了学习go语言，和了解并行的基本写法，这里通过一个demo练习</strong><br>由于已经有了c++和python的基础，所以了解基本语法很快，主要是学习go面向消息的传递机制，以及使用goroutine进行并发操作。<br>参考资料：<br><a href="https://www.runoob.com/go/go-concurrent.html">Go 语言教程-Go并发</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>hello.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*一个go的并行计算demo,学习go的基本语法，并计算两个数组元素值为1的数目*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//包声明：必须在源文件中非注释的第一行指明这个文件属于哪个包</span></span><br><span class="line"><span class="comment">//每个Go程序都包含一个名为main的包</span></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="comment">//import告诉Go编译器使用&quot;fmt&quot;包里的元素</span></span><br><span class="line"><span class="comment">//fmt包实现了格式化IO函数</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数声明方式</span></span><br><span class="line"><span class="comment">func function_name([parameter list])[return_types]&#123;</span></span><br><span class="line"><span class="comment">    函数体</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(arr []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    变量声明的两种方式：</span></span><br><span class="line"><span class="comment">    1.var v_name v_type = value</span></span><br><span class="line"><span class="comment">    2.v_name := value 根据值自行判定变量类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    注：标识符首字母大写，如Group 1，则可被外部包调用，称为导出。以小写字母开头则只能内部可见。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    循环定义方式 </span></span><br><span class="line"><span class="comment">    1.for init; condition； post&#123;&#125;</span></span><br><span class="line"><span class="comment">    2.for condition&#123;&#125;</span></span><br><span class="line"><span class="comment">    3.for key, value := range iter&#123;&#125;  用range对slice、map、数组等迭代循环</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        条件语句</span></span><br><span class="line"><span class="comment">        if 布尔表达式&#123;</span></span><br><span class="line"><span class="comment">            //语句</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> value == <span class="number">1</span>&#123;</span><br><span class="line">            <span class="comment">//运算符同c++，包括++，--</span></span><br><span class="line">            sum++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//值保存到通道（channel）方便并行</span></span><br><span class="line">    c &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数是程序开始执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</span><br><span class="line">    <span class="comment">//字符串输出到控制台，并结尾增加换行符&#x27;\n&#x27;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建数组方式一: var variable_name = [SIZE] variable_type&#123;,,,...&#125;</span></span><br><span class="line">    <span class="keyword">var</span> arr_a =[]<span class="type">int</span>  &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="comment">// 创建数组方式二: variable_name := [SIZE] variable_type&#123;,,,...&#125;</span></span><br><span class="line">    arr_b := []<span class="type">int</span> &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    函数调用方式: func([parameter_list])</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    goroutine: 轻量级线程，支持并发</span></span><br><span class="line"><span class="comment">    如果用goroutine调度，则前加go关键字，如go f(x,y,z)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">go</span> sum(arr_a, ch)</span><br><span class="line">    <span class="keyword">go</span> sum(arr_b, ch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    通道（channel）可用于两个goroutine之间通过传递一个指定的值来同步运行和通讯。</span></span><br><span class="line"><span class="comment">    操作符&lt;-用于指定通道的方向，发送或接收。如：</span></span><br><span class="line"><span class="comment">    ch &lt;- v //把v发送到通道ch</span></span><br><span class="line"><span class="comment">    v := &lt;- ch //从ch接收数据，并把值赋给v</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    result_a, result_b := &lt;- ch, &lt;- ch</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出计算结果</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;results&quot;</span>, result_a, result_b, result_a + result_b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p><img src="/images/helloworld.png" alt="输出结果"></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>002. win10安装python3.9.1+cuda11.1+cudnn+pytorch+opencv记录</title>
    <url>/2022/02/24/002-config-pytorch/</url>
    <content><![CDATA[<p>最近由于机器学习大作业需要用到神经网络，记录一下配置环境的过程。<br>前人铺路，我只是结合自己的环境做了一个简单的总结，写的不好多多见谅。</p>
<span id="more"></span>
<h1 id="1-安装python3-9"><a href="#1-安装python3-9" class="headerlink" title="1.安装python3.9"></a>1.安装python3.9</h1><p>首先是python的安装，选用当前时间最新版的python3.9.1<br>官网下载安装包即可<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a><br><img src="https://img-blog.csdnimg.cn/20201219134620158.png"></p>
<p>一路“下一步”，建议安装到默认路径。</p>
<p>然后，配置环境变量：<br>找到安装的位置，把图中所示的两个路径加入环境变量。<br>我的路径是：<br>C:\Users\Administrator\AppData\Local\Programs\Python\Python39<br>C:\Users\Administrator\AppData\Local\Programs\Python\Python39\Scripts<br><img src="https://img-blog.csdnimg.cn/20201219134237283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODA1NTk3,size_16,color_FFFFFF,t_70"><br>补充一点：<br>conda里python中的pytorch比较老，遇到没法调用的问题（这里没有深究），所以没有用anaconda，而是直接官网找最新的python。</p>
<h1 id="2-安装cuda（需要vs环境，我的是vs2015）"><a href="#2-安装cuda（需要vs环境，我的是vs2015）" class="headerlink" title="2.安装cuda（需要vs环境，我的是vs2015）"></a>2.安装cuda（需要vs环境，我的是vs2015）</h1><p>CUDA（Compute Unified Device Architecture），是显卡厂商NVIDIA推出的运算平台。</p>
<p>我当前的环境是vs2015，电脑配置是</p>
<p><img src="https://img-blog.csdnimg.cn/20201219142426303.png"><br><img src="https://img-blog.csdnimg.cn/20201219142440290.png"><br>注意CUDA的版本不能超过GPU的版本。</p>
<p>官网的CUDA安装路径如下：<br><a href="https://developer.nvidia.com/zh-cn/cuda-downloads">https://developer.nvidia.com/zh-cn/cuda-downloads</a><br><img src="https://img-blog.csdnimg.cn/20201219142239715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODA1NTk3,size_16,color_FFFFFF,t_70"><br>圈出来的部分，前者是一个比较大的安装包，下载到本地安装，后者是很小的安装包，但是需要联网，我选的前者。<br><img src="https://img-blog.csdnimg.cn/20201219142349445.png"></p>
<p>仍然选择当前最新的版本11.1，安装到默认路径下：<br>C:\Program Files\NVIDIA GPU Computing Toolkit</p>
<h1 id="3-安装cudnn（版本和cuda对应，更老的版本也可以但不建议）"><a href="#3-安装cudnn（版本和cuda对应，更老的版本也可以但不建议）" class="headerlink" title="3.安装cudnn（版本和cuda对应，更老的版本也可以但不建议）"></a>3.安装cudnn（版本和cuda对应，更老的版本也可以但不建议）</h1><p>NVIDIA cuDNN是用于深度神经网络的GPU加速库。<br>老规矩，走官网。<br><a href="https://developer.nvidia.com/rdp/cudnn-archive">https://developer.nvidia.com/rdp/cudnn-archive</a><br><img src="https://img-blog.csdnimg.cn/20201219140906756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODA1NTk3,size_16,color_FFFFFF,t_70"></p>
<p>这里的下载需要注册，有个技巧是复制链接，在迅雷打开可以直接下载。<br><img src="https://img-blog.csdnimg.cn/20201219135916291.png"></p>
<p>下载好的压缩包解压之后，会发现三个文件夹。<br>分别把文件放到cuda路径对应的文件夹下。<br><img src="https://img-blog.csdnimg.cn/20201219135443329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODA1NTk3,size_16,color_FFFFFF,t_70"></p>
<h1 id="4-安装pytorch"><a href="#4-安装pytorch" class="headerlink" title="4.安装pytorch"></a>4.安装pytorch</h1><p>它是一个基于Python的可续计算包，提供两个高级功能：1、具有强大的GPU加速的张量计算（如NumPy）。2、包含自动求导系统的深度神经网络。<br>官网：<br><a href="https://pytorch.org/get-started/locally/">https://pytorch.org/get-started/locally/</a><br><img src="https://img-blog.csdnimg.cn/20201219140414305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODA1NTk3,size_16,color_FFFFFF,t_70"><br>可以通过pip安装，最下面的命令行在cmd中打开即可。<br>由于速度慢，所以直接从别人那里拷贝过来了。</p>
<p>可以在python中通过下面的代码来检验，True表示pytorch的cuda配置成功<br><img src="https://img-blog.csdnimg.cn/20201219142901202.png"></p>
<h1 id="5-安装opencv"><a href="#5-安装opencv" class="headerlink" title="5.安装opencv"></a>5.安装opencv</h1><p>方法一：<br>打开cmd，输入<code>pip install opencv-python</code>即可，但超级慢还可能断开连接。<br>此处建议清华镜像下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install opencv-python -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</span><br></pre></td></tr></table></figure>

<p>方法二：<br>下载相应Python版本的OpenCV的whl文件<br><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#opencv">https://www.lfd.uci.edu/~gohlke/pythonlibs/#opencv</a><br>然后打开cmd，在whl文件对应文件夹路径下，使用pip安装，如<br><img src="https://img-blog.csdnimg.cn/20201219141255475.png"></p>
<h2 id="至此我需要的环境已经配置完成。"><a href="#至此我需要的环境已经配置完成。" class="headerlink" title="至此我需要的环境已经配置完成。"></a>至此我需要的环境已经配置完成。</h2>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>001. 如何连接实验室的服务器进行网络训练？</title>
    <url>/2022/02/24/001-link-to-server/</url>
    <content><![CDATA[<p>我在用电脑训练CNN时遇到了性能瓶颈（显存不够），当得知实验室的服务器算力更强时，去请教师兄怎么连。</p>
<p>实验室的师兄甩过来服务器的ip和用户名密码，说直接连就行。</p>
<p>直接连？linux都不太会用的小白，咋连？</p>
<p>首先确保连接到实验室的网络，我这边是用校园网或者挂校园网的VPN，然后有下面几种配置方法（方法应该很多，只是列出了我尝试过的这三种）：</p>
<span id="more"></span>
<h1 id="方法一：wsl（Windows-Subsystem-for-Linux）"><a href="#方法一：wsl（Windows-Subsystem-for-Linux）" class="headerlink" title="方法一：wsl（Windows Subsystem for Linux）"></a>方法一：wsl（Windows Subsystem for Linux）</h1><p>1.下载wsl2<br>参考<br><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10">https://docs.microsoft.com/zh-cn/windows/wsl/install-win10</a></p>
<p>2.下载windows终端windows terminal（非必须，也可直接用power shell）<br><a href="https://docs.microsoft.com/zh-cn/windows/terminal/get-started">https://docs.microsoft.com/zh-cn/windows/terminal/get-started</a></p>
<p>3.使用ssh命令进行外部链接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-&gt; ssh 用户@ip</span><br><span class="line">-&gt; 密码</span><br></pre></td></tr></table></figure>

<h1 id="方法二：vscode"><a href="#方法二：vscode" class="headerlink" title="方法二：vscode"></a>方法二：vscode</h1><p>1.vscode下载remote-ssh和remote wsl<br><img src="https://img-blog.csdnimg.cn/20210519110928571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODA1NTk3,size_16,color_FFFFFF,t_70"></p>
<p>2.连接服务器</p>
<p>选择左下角的标志<br><img src="https://img-blog.csdnimg.cn/20210519111221622.png"><br>会弹出一个菜单栏，选择Connect to Host…，输入用户名和密码即可<br><img src="https://img-blog.csdnimg.cn/20210519111159132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODA1NTk3,size_16,color_FFFFFF,t_70"></p>
<h1 id="方法三（推荐）：使用终端模拟器XShell和XFtp，学校和家庭有免费版"><a href="#方法三（推荐）：使用终端模拟器XShell和XFtp，学校和家庭有免费版" class="headerlink" title="方法三（推荐）：使用终端模拟器XShell和XFtp，学校和家庭有免费版"></a>方法三（推荐）：使用终端模拟器XShell和XFtp，学校和家庭有免费版</h1><p><a href="https://www.netsarang.com/zh/free-for-home-school/">https://www.netsarang.com/zh/free-for-home-school/</a><br><img src="https://img-blog.csdnimg.cn/2021051911143257.png"></p>
<p>XShell用来输入指令</p>
<p>XFtp方便文件管理和传输</p>
<p>当连接完成之后，就可以把使用GPU的网络训练代码放在服务器上跑了。。</p>
]]></content>
      <categories>
        <category>搭建环境</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
